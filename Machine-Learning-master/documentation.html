<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>Machine_Learning API documentation</title>
    <meta name="description" content="Machine_Learning is a module containing a class and functions for loading,
formatting, and interpola..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#Machine_Learning.convert_number_string_to_integer">convert_number_string_to_integer</a></li>
    <li class="mono"><a href="#Machine_Learning.get_classifier_comparision_results">get_classifier_comparision_results</a></li>
    <li class="mono"><a href="#Machine_Learning.get_multiple_data_arrays_as_list">get_multiple_data_arrays_as_list</a></li>
    <li class="mono"><a href="#Machine_Learning.get_percent_correct">get_percent_correct</a></li>
    <li class="mono"><a href="#Machine_Learning.graph_comparison_results">graph_comparison_results</a></li>
    <li class="mono"><a href="#Machine_Learning.make_prediction_graph">make_prediction_graph</a></li>
    <li class="mono"><a href="#Machine_Learning.plot_variable_array">plot_variable_array</a></li>
    <li class="mono"><a href="#Machine_Learning.predict_data_with_classifier">predict_data_with_classifier</a></li>
    <li class="mono"><a href="#Machine_Learning.predict_data_with_known_type_with_classifier">predict_data_with_known_type_with_classifier</a></li>
    <li class="mono"><a href="#Machine_Learning.split_csv_by_column">split_csv_by_column</a></li>
    <li class="mono"><a href="#Machine_Learning.split_csv_by_columns">split_csv_by_columns</a></li>
    <li class="mono"><a href="#Machine_Learning.split_table_by_column">split_table_by_column</a></li>
    <li class="mono"><a href="#Machine_Learning.split_table_by_columns">split_table_by_columns</a></li>
    <li class="mono"><a href="#Machine_Learning.train_classifier">train_classifier</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#Machine_Learning.DictionarySystem">DictionarySystem</a></span>
        
          
  <ul>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.__init__">__init__</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.get">get</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.get_dataset_variable_values">get_dataset_variable_values</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.interpolate_data">interpolate_data</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.items">items</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.iteritems">iteritems</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.iterkeys">iterkeys</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.itervalues">itervalues</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.keep_only_certain_columns">keep_only_certain_columns</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.keys">keys</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.make_fake_data_system_noise">make_fake_data_system_noise</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.make_fake_data_system_slope">make_fake_data_system_slope</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.pop">pop</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.remove_column_duplicates">remove_column_duplicates</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.remove_short_tables">remove_short_tables</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.split_by_column">split_by_column</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.split_by_columns">split_by_columns</a></li>
    <li class="mono"><a href="#Machine_Learning.DictionarySystem.values">values</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">Machine_Learning</span> module</h1>
  <p>Machine_Learning is a module containing a class and functions for loading,
formatting, and interpolating data, as well as generating fake data to be used,
training classifiers off of data, and performing tests on data.</p>
<h2>Requirements</h2>
<ul>
<li><a href="https://docs.python.org/2/library/copy.html">copy</a></li>
<li><a href="https://docs.python.org/2/library/random.html">random</a></li>
<li><a href="https://docs.python.org/2/library/collections.html">collections</a></li>
<li><a href="https://docs.scipy.org/doc/">numpy</a></li>
<li><a href="https://docs.scipy.org/doc/">scipy</a></li>
<li><a href="http://pandas.pydata.org/pandas-docs/stable/">pandas</a></li>
<li><a href="http://www.statsmodels.org/stable/index.html">statsmodels</a></li>
<li><a href="https://matplotlib.org/">matplotlib</a></li>
<li><a href="http://scikit-learn.org/stable/">scikit-learn</a></li>
</ul>
<h2>Examples</h2>
<ul>
<li><a href="HTML_Examples/Module_Introduction.html">Module Introduction</a></li>
<li><a href="HTML_Examples/Fake_Data_Creation.html">Fake Data Generation</a></li>
<li><a href="HTML_Examples/Classifier_Comparisons.html">Classifier Comparison</a></li>
</ul>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning" class="source">
    <div class="codehilite"><pre><span></span><span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Name:        Machine Learning</span>
<span class="c1"># Purpose:     Functions and a class for loading, formatting and interpolating data, as well as generating data,</span>
<span class="c1">#              training classifiers off of data, and performing tests.</span>
<span class="c1"># Author:      John Bass</span>
<span class="c1"># Created:     7/31/2017</span>
<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot; Machine_Learning is a module containing a class and functions for loading,</span>
<span class="sd">formatting, and interpolating data, as well as generating fake data to be used,</span>
<span class="sd">training classifiers off of data, and performing tests on data.</span>

<span class="sd">Requirements</span>
<span class="sd">------------</span>
<span class="sd">+ [copy](https://docs.python.org/2/library/copy.html)</span>
<span class="sd">+ [random](https://docs.python.org/2/library/random.html)</span>
<span class="sd">+ [collections](https://docs.python.org/2/library/collections.html)</span>
<span class="sd">+ [numpy](https://docs.scipy.org/doc/)</span>
<span class="sd">+ [scipy](https://docs.scipy.org/doc/)</span>
<span class="sd">+ [pandas](http://pandas.pydata.org/pandas-docs/stable/)</span>
<span class="sd">+ [statsmodels](http://www.statsmodels.org/stable/index.html)</span>
<span class="sd">+ [matplotlib](https://matplotlib.org/)</span>
<span class="sd">+ [scikit-learn](http://scikit-learn.org/stable/)</span>

<span class="sd">Examples</span>
<span class="sd">---------------</span>
<span class="sd">+ [Module Introduction](HTML_Examples/Module_Introduction.html)</span>
<span class="sd">+ [Fake Data Generation](HTML_Examples/Fake_Data_Creation.html)</span>
<span class="sd">+ [Classifier Comparison](HTML_Examples/Classifier_Comparisons.html)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># Standard Modules:</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="c1"># Non-Standard Modules:</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module numpy either was not found or had an error&quot;</span>
          <span class="s2">&quot;Please put it on the python path, or resolve the error&quot;</span><span class="p">)</span>
    <span class="k">raise</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module numpy either was not found or had an error&quot;</span>
          <span class="s2">&quot;Please put it on the python path, or resolve the error&quot;</span><span class="p">)</span>
    <span class="k">raise</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module scipy.interpolate either was not found or had an error&quot;</span>
          <span class="s2">&quot;Please put it on the python path, or resolve the error&quot;</span><span class="p">)</span>
    <span class="k">raise</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">statsmodels.nonparametric.smoothers_lowess</span> <span class="kn">import</span> <span class="n">lowess</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module statsmodels.nonparametric.smoothers_lowess.lowess either was not found or had an error&quot;</span>
          <span class="s2">&quot;Please put it on the python path, or resolve the error&quot;</span><span class="p">)</span>
    <span class="k">raise</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sklearn.utils</span> <span class="kn">import</span> <span class="n">shuffle</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module sklearn.utils.shuffle either was not found or had an error&quot;</span>
          <span class="s2">&quot;Please put it on the python path, or resolve the error&quot;</span><span class="p">)</span>
    <span class="k">raise</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">mpatches</span>
<span class="k">except</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;The module matplotlib was not found.&quot;</span>
          <span class="s2">&quot;Please put it on the python path.&quot;</span><span class="p">)</span>
    <span class="k">raise</span>


<span class="k">class</span> <span class="nc">DictionarySystem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;DictionarySystem is a class that contains a nested dictionary that has data that has been split by</span>
<span class="sd">    unique values of one or more variables. It is used to format and interpolate data,</span>
<span class="sd">    as well as generate entirely new data.&quot;&quot;&quot;</span>
    <span class="c1"># Functions:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basedict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To initialize a DictionarySystem,</span>
<span class="sd">        a nested dictionary must be inputted with the same format that a DictionarySystem uses.</span>

<span class="sd">        An easy way to create a DictionarySystem is to use any of the following 4 functions:</span>

<span class="sd">        * split_table_by_column</span>
<span class="sd">        * split_table_by_columns</span>
<span class="sd">        * split_csv_by_column</span>
<span class="sd">        * split_csv_by_columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Raises an error if basedict is not a dictionary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;basedict must be a dictionary!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Checks the validity of basedict. If basedict does not have the correct format,</span>
            <span class="c1"># or has value types that are not DictionarySystems, dictionaries,</span>
            <span class="c1"># or pandas Dataframes, raises a ValueError.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_dictionary_validity</span><span class="p">(</span><span class="n">basedict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">basedict</span>
                <span class="c1"># Converts all sub-dictionaries into DictionarySystems to</span>
                <span class="c1"># allow all of the recursive methods to work.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basedict is not in a valid format, or has invalid value types!&quot;</span><span class="p">)</span>
        <span class="c1"># This is just in case something goes dreadfully wrong, but hopefully it will never be called.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alright, I don&#39;t know what you even did, but something is wrong with basedict.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># This is made to only accept DictionarySystems, dictionaries, and pandas DataFrames,</span>
        <span class="c1"># or else it will throw an error. I am sure you can figure this method out.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value set is not a dictionary or pandas dataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;DictionarySystem(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># Old Dictionary Methods:</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns the keys of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a value for a given key inside the DictionarySystem&#39;s dictionary.</span>

<span class="sd">        **key:** the key to be searched in the dictionary.</span>

<span class="sd">        **default:** The value to be returned in case the key specified does not exist.</span>

<span class="sd">        **returns:** the value for the given key in side the FDictionarySystem&#39;s dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pops the value at the given key from the DictionarySystem&#39;s dictionary and returns it.</span>

<span class="sd">        **key:** The key to pop the value from</span>

<span class="sd">        **default:** If the given key does not exist within the DictionarySystem&#39;s dictionary,</span>
<span class="sd">        this value will be returned.</span>

<span class="sd">        **returns:** The value that was just popped from the given key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns the key,value pairs of the DictionarySystem&#39;s dictionary in tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns a list of all the values in the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iteritems method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iterkeys method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the itervalues method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span>

    <span class="c1"># Table Methods:</span>
    <span class="k">def</span> <span class="nf">split_by_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the dictionary system&#39;s tables by a single column,</span>
<span class="sd">        making the location where the table was a dictionary containing unique column values in the column as keys,</span>
<span class="sd">        with each key containing a table.</span>

<span class="sd">        **column:** The column to split the dictionary systems by.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at that key is a DictionarySystem it calls split_by_column on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="c1"># If the value at that key is a pandas DataFrame it tries to split it:</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># If the column specified is not in the DataFrame, the method raises a KeyError.</span>
                <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Column Specified is not in a table!&quot;</span><span class="p">)</span>
                <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># The method goes through all of the unique values in the column in the table,</span>
                <span class="c1"># creates new DataFrames containing only the unique value specified, and adds them to a dictionary.</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="c1"># The dictionary is then set to be the new value of the key.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dict</span><span class="p">)</span>
            <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
            <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem contains values other than DictionarySystems and tables!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_by_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the same thing as the split_by_column method, except splits by multiple columns in order instead of one.</span>

<span class="sd">        **columns:** The names of each column to split the tables by.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no columns are specified, the method raises a ValueError</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
        <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
        <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
        <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
        <span class="c1"># Jeez, I just realized that like 90% of this entire method is error checking.</span>
        <span class="c1"># Anyway, this now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
        <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
        <span class="c1"># and the method would be okay with it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># finally, after all that error checking, the method goes through the columns_flattened list in order, and</span>
        <span class="c1"># calls split_by_column with each column.</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_column_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all rows that have a duplicate value in a specific column</span>
<span class="sd">        except one in every table in the DictionarySystem,</span>
<span class="sd">        so that no duplicates in the said column will remain in the DictionarySystem.</span>

<span class="sd">        The way this removes columns is by going through each DataFrame in the DictionarySystem, and,</span>
<span class="sd">        for each DataFrame, a new DataFrame is created containing the first rows containing unique values in the initial</span>
<span class="sd">        DataFrame. The old DataFrame is then overwritten.</span>

<span class="sd">        **column:** The column used to remove duplicate values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_column_duplicates on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_column_duplicates</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="c1"># otherwise, if the value at the current key is a pandas DataFrame, it starts removing column duplicates.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># It sets the variable new_dataframe to none since I didn&#39;t want the variable to be local to</span>
                <span class="c1"># the for loop and I couldn&#39;t figure out any other way to do that.</span>
                <span class="n">new_dataframe</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="c1"># The method goes through all the unique values of the column specified.</span>
                <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                    <span class="c1"># Inside the for loop, the method creates a new DataFrame containing all the rows where the value</span>
                    <span class="c1"># in the specified column is the same as the for loop&#39;s unique value. It then selects the first</span>
                    <span class="c1"># row in that DataFrame and adds it to the new_dataframe variable. The result at the end of the</span>
                    <span class="c1"># for loop is a new dataframe where duplicate values in the specified column have been removed.</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">new_dataframe</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">new_dataframe</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]])</span>
                <span class="c1"># Finally the method just resets the index of this new DataFrame and sets the value at the current key</span>
                <span class="c1"># to be the new DataFrame with duplicate values removed, replacing the old DataFrame.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dataframe</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
            <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_short_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all tables in the DictionarySystem that are below a certain row count.</span>

<span class="sd">        **row_count:** The row count required for a table to stay in the DictionarySystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_short_tables on that.</span>
            <span class="c1"># If the DictionarySystem has no tables left in it after that, the method deletes the current key.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_short_tables</span><span class="p">(</span><span class="n">row_count</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is a pandas DataFrame and it&#39;s row count is</span>
            <span class="c1"># less than the specified minimum row count, the method deletes the current key.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row_count</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
            <span class="c1"># the method raises a ValueError.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keep_only_certain_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all columns in every table except the ones specified.</span>
<span class="sd">        This is generally used to remove irrelevant data from tables.</span>

<span class="sd">        **columns:** The names of the columns to keep in every table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no columns are specified, the method raises a ValueError</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
        <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
        <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
        <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
        <span class="c1"># The method now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
        <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
        <span class="c1"># and the method would be okay with it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Now, most of the error checking is done, so the method starts</span>
        <span class="c1"># going through the keys in the DictionarySystem.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem,</span>
            <span class="c1"># the keep_only_certain_columns method is called on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keep_only_certain_columns</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span>
            <span class="c1"># If the value a the current key is a DataFrame, the method sets the value at the current key to a new</span>
            <span class="c1"># DataFrame that only has the columns specified.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">columns_flattened</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
            <span class="c1"># the method will raise an error.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="c1"># Array Methods:</span>
    <span class="k">def</span> <span class="nf">interpolate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">num_points</span><span class="p">,</span>
                         <span class="n">independent_variable</span><span class="p">,</span>
                         <span class="n">dependent_variables</span><span class="p">,</span>
                         <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates independent and dependent variables in datasets within the DictionarySystem to have the amount</span>
<span class="sd">        of points specified. Unfortunately, columns that are not the independent or dependent variables will be removed,</span>
<span class="sd">        since they are not being interpolated and the dataframe has to stay rectangular.</span>

<span class="sd">        The independent variable must not have repeat values, and must be increasing. If these two requirements are not</span>
<span class="sd">        fulfilled, the method will fail.</span>

<span class="sd">        **num_points:** The amount of points the dependent variables will be interpolated to.</span>

<span class="sd">        **independent_variable:** The name of the independent variable of the dataset.</span>
<span class="sd">        All values of this variable must be increasing, and no duplicate values can exist.</span>

<span class="sd">        **dependent_variables:** An iterable containing the names of the dependent variables of the dataset.</span>

<span class="sd">        **interpolation_kind:** The kind of interpolation to be used. This will be fed into scipy&#39;s interp1d method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is easy to work with, we actually interpolate our data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                     <span class="n">num_points</span><span class="p">,</span>
                                                     <span class="n">independent_variable</span><span class="p">,</span>
                                                     <span class="n">dependent_variables</span><span class="p">,</span>
                                                     <span class="n">interpolation_kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
        <span class="c1"># Now that our data is interpolated, we convert all of the dictionaries containing</span>
        <span class="c1"># arrays representing columns back to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># We replace our object&#39;s dictionary with the newly interpolated one.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">nested_dictionaries</span>
        <span class="c1"># Now we simply convert all sub-dictionaries to DictionarySystems</span>
        <span class="c1"># to get everything back into the correct format.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">make_fake_data_system_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">independent_var</span><span class="p">,</span>
                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                    <span class="n">num_datasets</span><span class="p">,</span>
                                    <span class="n">location</span><span class="p">,</span>
                                    <span class="n">randomness_amplitudes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to</span>
<span class="sd">        the dependent variables of real datasets.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not have random noise added to it.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        These will have random noise added to their values to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to create</span>

<span class="sd">        **location:** The location to generate fake data at.</span>

<span class="sd">        **randomness_amplitudes** An iterable containing the random noise amplitudes for the random noise to be</span>
<span class="sd">        added to the values for each dependent variable.</span>

<span class="sd">        **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
        <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
        <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                        <span class="n">independent_var</span><span class="p">,</span>
                                                                        <span class="n">dependent_vars</span><span class="p">,</span>
                                                                        <span class="n">num_datasets</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="p">,</span>
                                                                        <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
        <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_fake_data_system_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">independent_var</span><span class="p">,</span>
                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                    <span class="n">num_datasets</span><span class="p">,</span>
                                    <span class="n">location</span><span class="p">,</span>
                                    <span class="n">starting_noises</span><span class="p">,</span>
                                    <span class="n">slope_deviations</span><span class="p">,</span>
                                    <span class="n">smoothing_fracs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to the</span>
<span class="sd">        first points of already existing datasets then adding random noise to the slopes between points of existing</span>
<span class="sd">        datasets and creating new points based off of those. After all this is done, a smoothing filter is applied to</span>
<span class="sd">        make the generated lines less jagged.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not be modified during fake data creation.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to be generated.</span>

<span class="sd">        **location:** The location to get datasets to be used to generate new datasets.</span>

<span class="sd">        **starting_noises:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        each dependent variable in existing datasets to generate new datasets.</span>

<span class="sd">        **slope_deviations:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        the slopes of the lines for each dependent variable to generate new datasets.</span>

<span class="sd">        **smoothing_fracs:** An Iterable containing the smoothing fracs for the lowess filter to apply to the</span>
<span class="sd">        generated lines for each dependent variable.</span>

<span class="sd">        **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
        <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
        <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                        <span class="n">independent_var</span><span class="p">,</span>
                                                                        <span class="n">dependent_vars</span><span class="p">,</span>
                                                                        <span class="n">num_datasets</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="p">,</span>
                                                                        <span class="n">starting_noises</span><span class="p">,</span>
                                                                        <span class="n">slope_deviations</span><span class="p">,</span>
                                                                        <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
        <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_variable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_variable</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This gets all of the values for a single variable, and returns them in an array containing lists containing the</span>
<span class="sd">        datapoints for the variable for a single dataset. This is used by a lot of methods, and in general is a format</span>
<span class="sd">        that is somewhat easy to work with.</span>

<span class="sd">        **dataset_variable:** The name of the variable to get all of the values for.</span>

<span class="sd">        **location:** The location to get the variable values from. If it is none, all of the values for the variable</span>
<span class="sd">        will be gotten.</span>

<span class="sd">        **returns:** All of the values of a single variable in an array, with the values being seperated into lists</span>
<span class="sd">        containing the values for a single dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="n">dataset_variable_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset_variable_values</span>

    <span class="c1"># Array Helper Methods:</span>
    <span class="k">def</span> <span class="nf">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                        <span class="n">dictionary</span><span class="p">,</span>
                                                        <span class="n">dataset_variable</span><span class="p">,</span>
                                                        <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method used by the get_dataset_variable_values method that actually gets the values of the variables for</span>
<span class="sd">        each dataset and outputs them in the right format. This method uses recursion so it had to be seperate from the</span>
<span class="sd">        other method.</span>

<span class="sd">        **dictionary:** The dictionary to get the values of the variables for each dataset from.</span>

<span class="sd">        **dataset_variable:** The name of the variable to get values from.</span>

<span class="sd">        **location:** The location to get the data from. If location is none, it will get dataset variable values</span>
<span class="sd">        from the entire dictionary.</span>

<span class="sd">        **returns** An array containing lists containing the values for a specific variable in each dataset,</span>
<span class="sd">        at the specified location.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no location was inputted, it simply gets all of the dataset</span>
        <span class="c1"># variable values in every dataset and returns an array of those.</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># This list will contain the list of values of the dataset variable for every dataset in</span>
            <span class="c1"># the DictionarySystem.</span>
            <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># If the value at the first key in the current dictionary is an array,</span>
                <span class="c1"># it adds the array whose key is the dataset variable name to variable_set_list</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="c1"># if the current location is an DictionarySystem that contains DictionarySystems representing</span>
                <span class="c1"># individual datasets, it goes through them calls get_dataset_variable_values to each one,</span>
                <span class="c1"># then adds them all to variable_set_list.</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">key_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="o">=</span><span class="p">[])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                <span class="c1"># if the current location is higher up in the nesting, the method calls get_dataset_variable_values on</span>
                <span class="c1"># the DictionarySystem at the current location and adds the results to variable_set_list.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
            <span class="c1"># Finally, variable_set_list is returned as an array.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
        <span class="c1"># Since location can also be a string, if it is, it checks to see if location is an empty string.</span>
        <span class="c1"># If location is an empty string, it calls get_dataset_variable_values with location being an empty tuple.</span>
        <span class="c1"># If location is not an empty string, it calls get_dataset_variable_values with location being a</span>
        <span class="c1"># single value tuple with the only value being the string that was just passed to location.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                            <span class="n">dataset_variable</span><span class="p">,</span>
                                                                            <span class="n">location</span><span class="o">=</span><span class="p">[])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                        <span class="n">dataset_variable</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="n">location</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># If location is an iterable, but not a string, then that means we are looking at some sort of path.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="c1"># If the length of location is 0, then that means that the current location is the location to</span>
            <span class="c1"># get the dataset variable&#39;s values from, so we go through the DictionarySystem at the current location</span>
            <span class="c1"># and add all of the values of the dataset variable to a list, then return it as an array.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
            <span class="c1"># If the length of location is 1 then we can do the same thing as when location is 0 with a bit of tweaking.</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
            <span class="c1"># If the length of location is greater than one then we just use recursion to our advantage.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                            <span class="n">dataset_variable</span><span class="p">,</span>
                                                                            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># If location is not None, a string, or an Iterable, we raise a ValueError.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;location must be an Iterable!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">independent_var</span><span class="p">,</span>
                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                <span class="n">location</span><span class="p">,</span>
                                                <span class="n">starting_noises</span><span class="p">,</span>
                                                <span class="n">slope_deviations</span><span class="p">,</span>
                                                <span class="n">smoothing_fracs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method used by the make_fake_data_system_slope method to generate fake data. This method is seperate from</span>
<span class="sd">        that method because this method requires the use of recursion.</span>

<span class="sd">        **dictionary:** The dictionary that will be used as a reference for the fake data generation.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not be modified during fake data creation.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to be generated.</span>

<span class="sd">        **location:** The location to get datasets to be used to generate new datasets.</span>

<span class="sd">        **starting_noises:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        each dependent variable in existing datasets to generate new datasets.</span>

<span class="sd">        **slope_deviations:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        the slopes of the lines for each dependent variable to generate new datasets.</span>

<span class="sd">        **smoothing_fracs:** An Iterable containing the smoothing fracs for the lowess filter to apply to the</span>
<span class="sd">        generated lines for each dependent variable.</span>

<span class="sd">        **returns:** A nested dictionary containing the newly generated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">fake_set_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">):</span>
                    <span class="c1"># Copying a random dataset in our already existing datasets,</span>
                    <span class="c1"># which will be modified to become fake data.</span>
                    <span class="n">new_set_values</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
                    <span class="c1"># This will go through each dependent variable&#39;s datapoints and modify them.</span>
                    <span class="k">for</span> <span class="n">dep_var_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dependent_vars</span><span class="p">)):</span>
                        <span class="c1"># This is the array of the old points from an existing dataset.</span>
                        <span class="n">dep_var_values</span> <span class="o">=</span> <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_vars</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">]]</span>
                        <span class="n">new_dep_var_points</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="c1"># This adds a random value to the starting value of dep_var_values,</span>
                        <span class="c1"># creating the first point in our fake dataset.</span>
                        <span class="n">starting_value</span> <span class="o">=</span> <span class="n">dep_var_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">starting_noises</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">])</span>
                        <span class="n">new_dep_var_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_value</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">set_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dep_var_values</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="c1"># We need to modify the slope, so we first have to get the slope.</span>
                            <span class="c1"># To do this, we first have to get the change in the x value:</span>
                            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">][</span><span class="n">set_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>\
                                      <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">][</span><span class="n">set_index</span><span class="p">]</span>
                            <span class="c1"># We also need to get the change in the y value:</span>
                            <span class="n">delta_y</span> <span class="o">=</span> <span class="n">dep_var_values</span><span class="p">[</span><span class="n">set_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dep_var_values</span><span class="p">[</span><span class="n">set_index</span><span class="p">]</span>
                            <span class="c1"># Now we simply calculate the slope:</span>
                            <span class="n">segment_slope</span> <span class="o">=</span> <span class="n">delta_y</span> <span class="o">/</span> <span class="n">delta_x</span>
                            <span class="c1"># We then add a random value to the slope,</span>
                            <span class="c1"># and use our new slope to calculate the next point.</span>
                            <span class="n">segment_slope</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">slope_deviations</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">])</span>
                            <span class="n">new_point_y_val</span> <span class="o">=</span> <span class="n">new_dep_var_points</span><span class="p">[</span><span class="n">set_index</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta_x</span> <span class="o">*</span> <span class="n">segment_slope</span><span class="p">)</span>
                            <span class="n">new_dep_var_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_point_y_val</span><span class="p">)</span>
                        <span class="c1"># Now that we have all of our points, we apply a smoothing filter to our points so that</span>
                        <span class="c1"># our curve will not have as many sharp edges.</span>
                        <span class="n">smoothed_dep_var_points</span> <span class="o">=</span> <span class="n">lowess</span><span class="p">(</span><span class="n">new_dep_var_points</span><span class="p">,</span>
                                                         <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">],</span>
                                                         <span class="n">is_sorted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                         <span class="n">frac</span><span class="o">=</span><span class="n">smoothing_fracs</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">],</span>
                                                         <span class="n">it</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_vars</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">smoothed_dep_var_points</span>
                    <span class="n">new_data_dict</span><span class="p">[</span><span class="s2">&quot;Fake Dataset &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fake_set_num</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_set_values</span>
                <span class="k">return</span> <span class="n">new_data_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the length of location is more than one, we simply use recursion to narrow down the location:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                                    <span class="n">starting_noises</span><span class="p">,</span>
                                                                    <span class="n">slope_deviations</span><span class="p">,</span>
                                                                    <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                <span class="n">independent_var</span><span class="p">,</span>
                                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="n">location</span><span class="p">],</span>
                                                                <span class="n">starting_noises</span><span class="p">,</span>
                                                                <span class="n">slope_deviations</span><span class="p">,</span>
                                                                <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location must be an iterable or a string!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">independent_var</span><span class="p">,</span>
                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                <span class="n">location</span><span class="p">,</span>
                                                <span class="n">randomness_amplitudes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method used by the make_fake_data_system_noise method to generate fake data. This method is seperate from</span>
<span class="sd">        that method because this method requires the use of recursion.</span>

<span class="sd">        **dictionary:** The dictionary that will be used as a reference for the fake data generation.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not have random noise added to it.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        These will have random noise added to their values to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to create.</span>

<span class="sd">        **location:** The location to generate fake data at.</span>

<span class="sd">        **randomness_amplitudes:** An iterable containing the random noise amplitudes for the random noise to be</span>
<span class="sd">        added to the values for each dependent variable.</span>

<span class="sd">        **returns:** A nested dictionary containing the newly generated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="c1"># If it&#39;s length is one, that means that means that all of the values in the current dictionary</span>
            <span class="c1"># are SUPPOSED to be dictionaries representing singular datasets.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># the current_location variable is just there so I don&#39;t have to keep writing location[0] a ton.</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># new_data_dict will contain all of the new, fake datasets.</span>
                <span class="n">new_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">):</span>
                    <span class="c1"># We need a deep copy of one of the datasets so that</span>
                    <span class="c1"># when we add random noise it won&#39;t affect the original dataset:</span>
                    <span class="n">new_set_values</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
                    <span class="c1"># Now we add random noise to every single dependent variable:</span>
                    <span class="k">for</span> <span class="n">dependent_var</span><span class="p">,</span> <span class="n">amp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependent_vars</span><span class="p">,</span> <span class="n">randomness_amplitudes</span><span class="p">):</span>
                        <span class="n">num_values_in_dataset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_var</span><span class="p">])</span>
                        <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_var</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">num_values_in_dataset</span><span class="p">)</span>
                    <span class="c1"># We now have a fake dataset, so we add it to new_data_dict, which contains all of our fake datasets</span>
                    <span class="n">new_data_dict</span><span class="p">[</span><span class="s2">&quot;Fake Dataset &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_set_values</span>
                <span class="c1"># ...and now we just return new_data_dict!</span>
                <span class="k">return</span> <span class="n">new_data_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the length of location is more than one, we simply use recursion to narrow down the location:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                                    <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># If location is a string, the same method is called, but location is now a single element list,</span>
        <span class="c1"># so that The above code can do it&#39;s magic.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                <span class="n">independent_var</span><span class="p">,</span>
                                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="n">location</span><span class="p">],</span>
                                                                <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># If location is not an iterable or a string, a ValueError is raised.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location must be an iterable or a string!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts a nested dictionary with dataframes at the end of the nesting to a nested dictionary with</span>
<span class="sd">        dictionaries containing arrays representing columns at the end of the nesting.</span>

<span class="sd">        **dictionary:** The dictionary to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If dictionary is not a dict, an error is raised.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter &#39;dictionary&#39; is not a dict, it is a &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a dataframe,</span>
            <span class="c1"># it gets converted into a dictionary containing lists representing columns.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
                <span class="c1"># All of the lists are now converted to arrays.</span>
                <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">])</span>
            <span class="c1"># If the value at the current key is a dict, it gets the method called on it.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts a nested dictionary with dictionaries containing arrays representing columns at the end of</span>
<span class="sd">        the nesting to a nested dictionary with dataframes at the end of the nesting.</span>

<span class="sd">        **dictionary: The dictionary to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If dictionary is not a dict, an error is raised.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter &#39;dictionary&#39; is not a dict, it is a &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a dictionary containing arrays representing columns,</span>
            <span class="c1"># It gets converted to a dataframe.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># If the value at the current key is a dict, it gets the method called on it.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">num_points</span><span class="p">,</span>
                                                <span class="n">independent_variable</span><span class="p">,</span>
                                                <span class="n">dependent_variables</span><span class="p">,</span>
                                                <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the method that actually interpolates the data in a nested dictionary, and is only called by</span>
<span class="sd">        the interpolate_data method. The reason why this method and the interpolate_data method are separate methods is</span>
<span class="sd">        because this method requires recursion.</span>

<span class="sd">        **dictionary:** A nested dictionary which will have its datasets interpolated.</span>

<span class="sd">        **num_points:** The amount of points the dependent variables will be interpolated to.</span>

<span class="sd">        **independent_variable:** The name of the independent variable of the dataset.</span>
<span class="sd">        All values of this variable must be increasing, and no duplicate values can exist.</span>

<span class="sd">        **dependent_variables:** An iterable containing the names of the dependent variables of the dataset.</span>

<span class="sd">        **interpolation_kind:** The kind of interpolation to be used. This will be fed into scipy&#39;s interp1d method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">dataset_key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">independent_variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Independent variable specified is not a key in the DictionarySystem!&quot;</span><span class="p">)</span>
                    <span class="c1"># All of this here is simple code to find these maxes of minimums and minimums of maxes:</span>
                    <span class="k">if</span> <span class="n">maximum_of_mins</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">maximum_of_mins</span><span class="p">:</span>
                        <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">minimum_of_maxes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minimum_of_maxes</span><span class="p">:</span>
                        <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="c1"># Now that we have the bounds for our interpolation, we need to make our interpolation functions:</span>
                <span class="k">for</span> <span class="n">dataset_key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># First we need to get the values for the independent and</span>
                    <span class="c1"># dependent variables in this specific dataset:</span>
                    <span class="n">independent_var_values</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">dependent_var_values</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">variable_name</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">variable_name</span> <span class="ow">in</span> <span class="n">dependent_variables</span><span class="p">]</span>
                    <span class="c1"># This list will hold the interpolation functions soon:</span>
                    <span class="n">dependent_var_interpolation_functions</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">dependent_var_list</span> <span class="ow">in</span> <span class="n">dependent_var_values</span><span class="p">:</span>
                        <span class="c1"># Now, we simply use scipy&#39;s interp1d function to get our interpolation functions:</span>
                        <span class="n">var_function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">independent_var_values</span><span class="p">,</span>
                                                            <span class="n">dependent_var_list</span><span class="p">,</span>
                                                            <span class="n">interpolation_kind</span><span class="p">)</span>
                        <span class="n">dependent_var_interpolation_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_function</span><span class="p">)</span>
                    <span class="c1"># The new independent variable values should be uniform, so we just use np.linspace:</span>
                    <span class="n">new_independent_var_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">maximum_of_mins</span><span class="p">,</span> <span class="n">minimum_of_maxes</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
                    <span class="c1"># This list will be used to store our dependent variable values</span>
                    <span class="c1"># once we use the interpolation functions we just made:</span>
                    <span class="n">new_dependent_var_values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Now we go through our interpolation functions and</span>
                        <span class="c1"># get new values for all of our dependent variables:</span>
                        <span class="k">for</span> <span class="n">interp_function</span> <span class="ow">in</span> <span class="n">dependent_var_interpolation_functions</span><span class="p">:</span>
                            <span class="n">new_dependent_var_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp_function</span><span class="p">(</span><span class="n">new_independent_var_values</span><span class="p">))</span>
                        <span class="c1"># We make a dictionary out of these new values using variable names as keys:</span>
                        <span class="n">interpolated_dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dependent_variables</span><span class="p">,</span> <span class="n">new_dependent_var_values</span><span class="p">))</span>
                        <span class="n">interpolated_dictionary</span><span class="p">[</span><span class="n">independent_variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_independent_var_values</span>
                        <span class="c1"># Finally, we replace our old DictionarySystem for this dataset with</span>
                        <span class="c1"># our newly interpolated one. By the way, we are inputting a dictionary, but the __setitem__</span>
                        <span class="c1"># method will convert it into an DictionarySystem, so we do not have to worry about that.</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_dictionary</span>
                    <span class="c1"># Sometimes interpolation fails because some dataset&#39;s bounds are outside of the</span>
                    <span class="c1"># interpolation range we just got, so this is here to just remove all the datasets that do that.</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span>
                        <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                             <span class="n">num_points</span><span class="p">,</span>
                                                             <span class="n">independent_variable</span><span class="p">,</span>
                                                             <span class="n">dependent_variables</span><span class="p">,</span>
                                                             <span class="n">interpolation_kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Something went wrong, change this error message later&quot;</span><span class="p">)</span>

    <span class="c1"># Other Helper Methods:</span>
    <span class="k">def</span> <span class="nf">__get_nested_dictionaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This gets all of the dictionaries in the nested DictionarySystems</span>
<span class="sd">        and returns them as a nested dictionary structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This will soon contain all of the nested dictionaries in the DictionarySystem.</span>
        <span class="n">nested_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># This basically goes through the DictionarySystem, calling the same method on sub-DictionarySystems and</span>
        <span class="c1"># appending their results to the dictionary, as well as adding any non-DictionarySystem values to the dictionary</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="n">nested_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nested_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Finally, our nested dictionary is just returned. Due to recursion, a full nested dictionary structure will</span>
        <span class="c1"># Eventually be outputted.</span>
        <span class="k">return</span> <span class="n">nested_dict</span>

    <span class="k">def</span> <span class="nf">__check_dictionary_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a dictionary has a valid format and valid variable types to become a DictionarySystem.</span>

<span class="sd">        **dictionary:** The dictionary to check.</span>

<span class="sd">        **returns:** True or False depending on whether a dictionary has a valid format and valid variable types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the dictionary variable inputted is not a dictionary, returns False.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># If any value in the dictionary is not a DictionarySystem, dictionary, or</span>
                <span class="c1"># pandas DataFrame, returns False.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="c1"># If the __check_dictionary_validity method fails on any sub dictionaries, returns False.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_dictionary_validity</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># If it never returned False, returns True.</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__convert_dicts_to_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts all sub-dictionaries in the DictionarySystem&#39;s main dictionary into DictionarySystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Literally all this does is if any value in the DictionarySystem is a dictionary, it gets turned into a</span>
        <span class="c1"># DictionarySystem.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__better_flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Some flattening method I found on stackoverflow, which I a few methods</span>
<span class="sd">        to make the flattening of my columns arguments work.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable_object</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">newvalue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">newvalue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">split_table_by_column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas DataFrame and splits it by column values into a DictionarySystem.</span>

<span class="sd">    **table:** The Dataframe to split into a DictionarySystem.</span>

<span class="sd">    **column:** The column to split the pandas DataFrame by.</span>

<span class="sd">    **returns:** A DictionarySystem created by splitting the pandas DataFrame inputted by the column inputted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Goes through every unique value in the specified column of the the table inputted</span>
    <span class="n">unique_column_vals</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_column_vals</span><span class="p">:</span>
        <span class="c1"># Adds to the dictionary a new table with every value in the</span>
        <span class="c1"># specified column being the current unique value from the for loop.</span>
        <span class="n">table_dictionary</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">table_dictionary</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">split_table_by_columns</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas DataFrame and splits it by all of the columns specified into a DictionarySystem</span>

<span class="sd">    **table:** The Dataframe to split into a DictionarySystem.</span>

<span class="sd">    **columns:** The columns to split the pandas DataFrame by.</span>

<span class="sd">    **returns:** A DictionarySystem created by splitting the pandas DataFrame inputted by the columns inputted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Raises a ValueError if no columns are inputted:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># Splits the table by the first column:</span>
    <span class="n">dictionary_system</span> <span class="o">=</span> <span class="n">split_table_by_column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># If more than one column was specified, split the DictionarySystem by the extra columns as well.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dictionary_system</span><span class="o">.</span><span class="n">split_by_columns</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">dictionary_system</span>


<span class="k">def</span> <span class="nf">split_csv_by_column</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a csv file, loads it as a pandas dataframe, splits it by a column,</span>
<span class="sd">    and returns the resulting DictionarySystem.</span>

<span class="sd">    **path:** The path to a csv file.</span>

<span class="sd">    **column:** The column to split the pandas dataframe by.</span>

<span class="sd">    **returns:** A DictionarySystem that is the result of splitting the</span>
<span class="sd">    table contained in the csv file specified by the column specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_table_by_column</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">split_csv_by_columns</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a csv file, loads it as a pandas dataframe, splits it by multiple columns,</span>
<span class="sd">    and returns the resulting DictionarySystem.</span>

<span class="sd">    **path:** The path to a csv file.</span>

<span class="sd">    **columns:** The columns to split the pandas dataframe by.</span>

<span class="sd">    **returns:** A DictionarySystem that is the result of splitting the</span>
<span class="sd">    table contained in the csv file specified by the columns specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_table_by_columns</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">)</span>


<span class="c1"># Actions for value Arrays:</span>
<span class="k">def</span> <span class="nf">plot_variable_array</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">,</span>
                        <span class="n">dependent_variable_arr</span><span class="p">,</span>
                        <span class="n">num_lines</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                        <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes two arrays containing lists of values and graphs lines from the information in the arrays.</span>

<span class="sd">    **independent_variable_arr:** a two dimensional array containing lists of values for the x-axis.</span>

<span class="sd">    **dependent_variable_arr:** a two dimensional array containing lists of values for the y-axis.</span>

<span class="sd">    **num_lines:** The amount of lines to be graphed.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># These lines get the actual amount of lines to graph, since strings can be inputted in num_lines.</span>
    <span class="c1"># It will also raise an error if num_lines is not a valid string or int, so that is just an added bonus!</span>
    <span class="n">new_num_lines</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">num_lines</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">convert_number_string_to_integer</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_points is not an int or a string!&quot;</span><span class="p">)</span>
    <span class="c1"># Before the function actually graphs lines, it checks to see if the amount of lines the user wants to graph</span>
    <span class="c1"># is bigger than the amount of lines that are possible to be graphed, just in case.</span>
    <span class="k">if</span> <span class="n">new_num_lines</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_num_lines</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dependent_variable_arr</span><span class="p">):</span>
        <span class="c1"># The function plots the amount of lines specified by the function call.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_num_lines</span><span class="p">):</span>
            <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dependent_variable_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_lines is bigger than the amount of lines that are possible to graph!&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">train_classifier</span><span class="p">(</span><span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;Random Forest&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">data_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accepts arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method and</span>
<span class="sd">    returns a classifier that has been trained off of the data specified.</span>

<span class="sd">    **classifier_type:** The type of classifier to be trained.</span>
<span class="sd">    A classifier CLASS (not object) can be inputted,</span>
<span class="sd">    or a string can be inputted with the name of the classifiers;</span>
<span class="sd">    keep in mind this does not work for every classifier available, but a lot of classifiers are valid.</span>

<span class="sd">    **data_dictionary:** keyword arguments with the keys containing the prediction values and</span>
<span class="sd">    the values being an arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method</span>

<span class="sd">    **returns:** a classifier that has been trained off of the data specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier_type</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="c1"># I am importing inside the function since these will only be used in the specific circumstance that</span>
        <span class="c1"># a user inputted a string for classifier_type.</span>
        <span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="kn">import</span> <span class="n">QuadraticDiscriminantAnalysis</span>
        <span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">GaussianNB</span><span class="p">,</span> <span class="n">BernoulliNB</span><span class="p">,</span> <span class="n">MultinomialNB</span>
        <span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
        <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
        <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">RidgeClassifier</span><span class="p">,</span> <span class="n">SGDClassifier</span><span class="p">,</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">,</span> <span class="n">Perceptron</span>
        <span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
        <span class="c1"># A giant dictionary of classifiers in case the user inputted a string for classifier_type:</span>
        <span class="n">classifiers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;randomforest&quot;</span><span class="p">:</span> <span class="n">RandomForestClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;quadraticdiscriminantanalysis&quot;</span><span class="p">:</span> <span class="n">QuadraticDiscriminantAnalysis</span><span class="p">(),</span>
            <span class="s2">&quot;gaussiannb&quot;</span><span class="p">:</span> <span class="n">GaussianNB</span><span class="p">(),</span>
            <span class="s2">&quot;gaussiannaivebayes&quot;</span><span class="p">:</span> <span class="n">GaussianNB</span><span class="p">(),</span>
            <span class="s2">&quot;bernoullinb&quot;</span><span class="p">:</span> <span class="n">BernoulliNB</span><span class="p">(),</span>
            <span class="s2">&quot;bernoullinaivebayes&quot;</span><span class="p">:</span> <span class="n">BernoulliNB</span><span class="p">(),</span>
            <span class="s2">&quot;multinomialnb&quot;</span><span class="p">:</span> <span class="n">MultinomialNB</span><span class="p">(),</span>
            <span class="s2">&quot;multinomialnaivebayes&quot;</span><span class="p">:</span> <span class="n">MultinomialNB</span><span class="p">(),</span>
            <span class="s2">&quot;decisiontree&quot;</span><span class="p">:</span> <span class="n">DecisionTreeClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;ridge&quot;</span><span class="p">:</span> <span class="n">RidgeClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;sgd&quot;</span><span class="p">:</span> <span class="n">SGDClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;stochasticgradientdescent&quot;</span><span class="p">:</span> <span class="n">SGDClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;passiveaggressive&quot;</span><span class="p">:</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;perceptron&quot;</span><span class="p">:</span> <span class="n">Perceptron</span><span class="p">(),</span>
            <span class="s2">&quot;svc&quot;</span><span class="p">:</span> <span class="n">SVC</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1"># Now, because people can type things in in different ways,</span>
        <span class="c1"># we try to make this string system as fool-proof as possible!</span>
        <span class="c1"># First, we set all the characters to lower case:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">classifier_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># Then we remove all underscores and spaces:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">formatted_classifier_type</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot; _&quot;</span><span class="p">)</span>
        <span class="c1"># Then we remove all instances of the word &quot;classifier&quot;:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">formatted_classifier_type</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;classifier&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># Now, we check to see if they actually inputted a classifier we know! If they didn&#39;t, we raise a ValueError.</span>
        <span class="k">if</span> <span class="n">formatted_classifier_type</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">:</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">formatted_classifier_type</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Classifier name inputted is not a supported classifier type!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># So what would happen if the individual inputted their own classifier type for a classifier?</span>
        <span class="c1"># Well, this covers that! Using the check_estimator function, we can tell if the inputted classifier is valid,</span>
        <span class="c1"># and raise an error if it isn&#39;t.</span>
        <span class="c1"># Keep in mind I am importing this here because if the user never inputs a classifier&#39;s class for</span>
        <span class="c1"># classifier_type, this import would never be used.</span>
        <span class="kn">from</span> <span class="nn">sklearn.utils.estimator_checks</span> <span class="kn">import</span> <span class="n">check_estimator</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_estimator</span><span class="p">(</span><span class="n">classifier_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyboardInterrupt</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Estimator inputted is not a valid estimator, &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;use sklearn&#39;s check_estimator function for more information!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifier_type</span><span class="p">()</span>
    <span class="c1"># Now we need to get our data in the correct format! First, we define two lists:</span>
    <span class="c1"># the training list which will contain the data,</span>
    <span class="c1"># and the target list which will contain what value each dataset is supposed to be.</span>
    <span class="n">training_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">target_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Now we iterate through our keyword arguments, to add values to these two lists.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="c1"># If the value at the current key is a numpy array, we just add all of it&#39;s values to the training list,</span>
        <span class="c1"># and it&#39;s key multiple times to the target list.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="c1"># We do the same thing with the list.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="c1"># If the value at the current key is another form of iterable, we convert it to a list and do the same thing.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">value_as_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">)</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">))</span>
        <span class="c1"># If the value is not any type of iterable, we raise a ValueError.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keyword argument has been inputted that is not an array or iterable&quot;</span><span class="p">)</span>
    <span class="c1"># Now we convert both lists to arrays, because they must be arrays to be put through the classifier.</span>
    <span class="n">training_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">training_list</span><span class="p">)</span>
    <span class="n">target_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_list</span><span class="p">)</span>
    <span class="c1"># To make sure no bias appears in the classifier, we shuffle both of the arrays in the same way.</span>
    <span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Finally, we fit the classifier and return it.</span>
    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clf</span>


<span class="k">def</span> <span class="nf">predict_data_with_classifier</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span> <span class="o">*</span><span class="n">data_arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This takes a trained classifier and a variable amount of arrays of data created by</span>
<span class="sd">    DictionarySystem&#39;s get_dataset_variable_values method and returns the predictions of the classifier for the</span>
<span class="sd">    arrays of data, in a list.</span>

<span class="sd">    **trained_classifier:** A trained classifier.</span>

<span class="sd">    **data_arrays:** Arrays of data created by DictionarySystem&#39;s get_dataset_variable_values method.</span>

<span class="sd">    **returns:** predictions of the classifier for the arrays of data,</span>
<span class="sd">    in the format that the data_arrays arguments was inputted in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Since I want this to be as open ended as possible,</span>
        <span class="c1"># I am trying to allow people to input multiple arrays of data.</span>
        <span class="c1"># Because of this, since more than one value in data_arrays was inputted,</span>
        <span class="c1"># we first need to go through all of the arrays of data and add them to a universal testing_data list.</span>
        <span class="c1"># Also, technically, they don&#39;t have to be arrays, but I would like them to be.</span>
        <span class="n">testing_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>
        <span class="c1"># Now, it just predicts and returns the predicted data.</span>
        <span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># I prefer going through lists with numerical indexes, so I did that,</span>
        <span class="c1"># but this can easily be changed if it needs to be.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">testing_data</span><span class="p">)):</span>
            <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">testing_data</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_list</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Well, if we have a single argument inputted, we don&#39;t want to be returning a single value list,</span>
        <span class="c1"># so this is intended to stop that from happening. I won&#39;t comment anything else in this part because</span>
        <span class="c1"># it is basically a simplified version of the above code.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">predict_data_with_known_type_with_classifier</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span> <span class="o">**</span><span class="n">data_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function does the same thing as the predict_data_with_classifier function,</span>
<span class="sd">    except returns two lists: expected and predicted. expected contains the actual type of each dataset,</span>
<span class="sd">    and predicted contains the predicted type of each dataset.</span>

<span class="sd">    **trained_classifier:** a trained classifier</span>

<span class="sd">    **data_dictionary:** keyword arguments with the keys containing the prediction values and</span>
<span class="sd">    the values being an arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method</span>

<span class="sd">    **returns:** a tuple containing the expected array first and the predicted array second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Before I start explaining everything, I want to say that, for certain reasons, this function does not retain the</span>
    <span class="c1"># structure of data_dictionary like the predict_data_with_classifier does. It simply returns two lists: expected,</span>
    <span class="c1"># and predicted, because I couldn&#39;t figure out how to do anything else. If somebody needs to get their original</span>
    <span class="c1"># data into a list of the same format, they can use the get_multiple_data_arrays_as_list function.</span>
    <span class="c1">#</span>
    <span class="c1"># Alright, so this following part is basically a copy-pasted version of code in the train_classifier function,</span>
    <span class="c1"># so if you do not understand this, I recommend you go there.</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">value_as_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">)</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keyword argument has been inputted that is not an array or iterable&quot;</span><span class="p">)</span>
    <span class="c1"># We now turn the two lists into arrays, and shuffle them:</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="n">test_list</span><span class="p">,</span> <span class="n">expected</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Next we use the classifier to predict the data.</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="c1"># Finally, we return both lists.</span>
    <span class="k">return</span> <span class="n">expected</span><span class="p">,</span> <span class="n">predicted</span>


<span class="k">def</span> <span class="nf">make_prediction_graph</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span>
                          <span class="n">x_axis</span><span class="p">,</span>
                          <span class="n">data_array</span><span class="p">,</span>
                          <span class="n">num_lines</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                          <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">z_indexes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a trained classifier and a lot of information and</span>
<span class="sd">    draws a graph depicting lines that went through the classifier,</span>
<span class="sd">    with their color indicating what the classifier predicted they were.</span>

<span class="sd">    **trained_classifier:** A trained classifier to be used for predictions of the data specified.</span>

<span class="sd">    **x_axis:** some type of iterable object containing values to be used for</span>
<span class="sd">    the x values of points in datasets specified by the kwargs.</span>

<span class="sd">    **data_array:** An array containing all the datasets to be tested by the classifier.</span>

<span class="sd">    **num_lines:** the amount of lines to be plotted on the graph. Accepted values are any integer,</span>
<span class="sd">    the string &quot;all&quot; if you want all lines to be plotted,</span>
<span class="sd">    and the string &quot;half&quot; if you want half of the lines to be plotted.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **z_indexes:** a dictionary with keys being all of the kwarg keys,</span>
<span class="sd">    which contains z indexes for different predicted results.</span>
<span class="sd">    If not specified or set to None, the default z indexes will be used.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># Now, we shuffle the data_array variable, and use our classifier to get predicted values.</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="c1"># Next, we set some variables to be used later.</span>
    <span class="n">color_types</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">graph_handles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Now, we get the actual amount of lines we need to plot.</span>
    <span class="n">new_num_lines</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">num_lines</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">convert_number_string_to_integer</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_lines must be an integer or a string!&quot;</span><span class="p">)</span>
    <span class="c1"># Now we start going through each line and what the classifier predicted for each one.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">predicted_value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">)),</span> <span class="n">test_list</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
        <span class="c1"># If we have gone past the amount of lines we want to graph, we break out of the for loop.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">new_num_lines</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Now we check to see if the predicted value for this line has been plotted before,</span>
        <span class="c1"># and therefore already has a color.</span>
        <span class="k">if</span> <span class="n">predicted_value</span> <span class="ow">in</span> <span class="n">color_types</span><span class="p">:</span>
            <span class="c1"># If it does, we check to see if z_indexes is not None.</span>
            <span class="c1"># If it isn&#39;t None, then we give it its assigned z index; otherwise, we leave it at the default.</span>
            <span class="k">if</span> <span class="n">z_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="n">zorder</span><span class="o">=</span><span class="n">z_indexes</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Right now, we have a line that has a predicted value that has not been plotted yet.</span>
            <span class="c1"># Because of this, first we have to plot it:</span>
            <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">z_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                                               <span class="n">zorder</span><span class="o">=</span><span class="n">z_indexes</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                         <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="c1"># Now, since matplotlib has automatically assigned this line a color,</span>
            <span class="c1"># we add the color to the color_types dictionary,</span>
            <span class="c1"># with it&#39;s key being the predicted value for the current line.</span>
            <span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">plotted_stuff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span>
            <span class="c1"># We also add a handle for this color, for the legend later on.</span>
            <span class="n">graph_handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">))</span>
    <span class="c1"># Now we create a legend showing all of the colors of the lines and all of their respective values.</span>
    <span class="c1"># The legend gets added to the side, though I may add functionality to edit it&#39;s location later.</span>
    <span class="n">plot_axis</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">graph_handles</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">convert_number_string_to_integer</span><span class="p">(</span><span class="n">number_string</span><span class="p">,</span> <span class="n">max_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a small function which is used in some other functions which,</span>
<span class="sd">    if number_string is an integer within a string, returns that integer,</span>
<span class="sd">    and if number_string is an indication of percentage, like &quot;tenth&quot; or &quot;seventh&quot; it returns that amount of max_values.</span>
<span class="sd">    For instance, if &quot;third&quot; is inputted for number_string, and max_values is thirty, 10 would be returned.</span>

<span class="sd">    **number_string:** The string containing the integer or indication of percentage.</span>

<span class="sd">    **max_values:** The maximum amount of values in a dataset or something,</span>
<span class="sd">    this is used for strings that indicate percentage.</span>

<span class="sd">    **returns:** The integer the number string contains or the integer calculated by the percentage number_string contains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If number_string contains only a number, it returns that number.</span>
    <span class="k">if</span> <span class="n">number_string</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_string</span><span class="p">)</span>
    <span class="c1"># These are the valid indications of percentage to be used.</span>
    <span class="n">string_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;half&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;quarter&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;fifth&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s2">&quot;sixth&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s2">&quot;seventh&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s2">&quot;eighth&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="s2">&quot;ninth&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s2">&quot;tenth&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># If number_string is one of the valid indications of percentage, it returns the number that is that percentage.</span>
    <span class="k">if</span> <span class="n">number_string</span> <span class="ow">in</span> <span class="n">string_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_values</span><span class="o">//</span><span class="n">string_dict</span><span class="p">[</span><span class="n">number_string</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;String inputted does not contain an integer or a valid indication of percentage!&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_multiple_data_arrays_as_list</span><span class="p">(</span><span class="o">*</span><span class="n">data_arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since the predict_data_with_known_type_with_classifier function only returns two lists, this function exists to get</span>
<span class="sd">    a set of multiple data arrays into the same list format as the predict_data_with_known_type_with_classifier function.</span>

<span class="sd">    **data_arrays:** The arrays to turn into a list.</span>

<span class="sd">    **returns:** the combined list of all of the data arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_array_combined_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># This for loop just goes through the data_arrays dictionary and adds all the iterables in it to</span>
    <span class="c1"># data_array_combined_list as numpy arrays.</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_array_combined_list</span>


<span class="k">def</span> <span class="nf">get_classifier_comparision_results</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">,</span>
                                       <span class="n">randomness_amplitude_range</span><span class="p">,</span>
                                       <span class="n">classifiers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes an array of &#39;good&#39; datasets, as well as an array of random noise amplitudes to test and classifier types</span>
<span class="sd">    as keyword arguments, and returns data to be graphed in the graph_comparison_results.</span>
<span class="sd">    These two functions together will make a graph showing the percentage of guesses that were correct at</span>
<span class="sd">    different random noise amplitudes for different classifiers. Users can use this to compare the performance</span>
<span class="sd">    of different classifiers. The reason why these functions are separate is because since this process takes a large</span>
<span class="sd">    amount of time, so if the functions are separated, it becomes a lot easier to quickly modify a plot to one&#39;s liking</span>
<span class="sd">    if the two functions are in an ipython notebook or something similar.</span>

<span class="sd">    **good_datasets:** An array of good datasets for a single variable.</span>

<span class="sd">    **randomness_amplitude_range:** An array all of the random noise amplitudes to use for &quot;bad&quot; data in tests.</span>

<span class="sd">    **classifiers:** A dictionary containing the classifier&#39;s CLASSES, not classifier objects, to test.</span>
<span class="sd">    Each key must be the name of each classifier.</span>

<span class="sd">    **returns:** Data to be used by the graph_comparison_results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This will contain the results at each point for each classifier.</span>
    <span class="n">classifier_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># This will contain all the amplitudes later.</span>
    <span class="n">final_range</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Each key of classifier_results will be the name of a classifier, and each value will be a list of floats,</span>
    <span class="c1"># each one detailling the percentage of predictions the classifier got correct at a specific point.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">classifier_results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">amplitude</span> <span class="ow">in</span> <span class="n">randomness_amplitude_range</span><span class="p">:</span>
        <span class="c1"># Now we generate an array of bad datasets, from the good ones.</span>
        <span class="c1"># We have to do this manually, since this isn&#39;t an DictionarySystem and we don&#39;t have a function for it.</span>
        <span class="n">bad_datasets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">)):</span>
            <span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">+</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">])))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">new_good_datasets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="c1"># Although the following variable is called &quot;training_data&quot;, we will also be using it for testing.</span>
        <span class="c1"># One half of it will be used to train each classifier, the other half will be used to test each classifier.</span>
        <span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">new_good_datasets</span><span class="p">,</span> <span class="n">bad_datasets</span><span class="p">))</span>
        <span class="c1"># We need to make all of the values positive, since some classifiers</span>
        <span class="c1"># apparently don&#39;t work well with negative values.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">])):</span>
                <span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">value</span><span class="p">])</span>
        <span class="c1"># Our target data will simply be &quot;good&quot; and &quot;bad&quot;. At some point, I should probably add a</span>
        <span class="c1"># feature to be able to put in your own data to compare classifiers in non-binary classification,</span>
        <span class="c1"># but right now I am too tired.</span>
        <span class="n">target_data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;good&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="n">target_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;bad&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">))</span>
        <span class="c1"># To remove bias, we shuffle both the training and target datasets.</span>
        <span class="n">training_data</span><span class="p">,</span> <span class="n">target_data</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># This is the number of datasets, I am just defining this to make it easier in the next part.</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># We have to initialize the current classifier type here, and set it to a variable.</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">key</span><span class="p">]()</span>
            <span class="c1"># Now we train it with half of the data.</span>
            <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_data</span><span class="p">[:</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">target_data</span><span class="p">[:</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
            <span class="c1"># This is what a classifier would predict if it got its predictions 100% correct.</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>
            <span class="c1"># This is what the classifier actually predicted.</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:])</span>
            <span class="c1"># Now, we just add up how many predictions the classifier got right:</span>
            <span class="n">num_correct</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">predicted</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                    <span class="n">num_correct</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># We now use this number to calculate the percentage correct for this classifier</span>
            <span class="c1"># at this random noise amplitude, then add it to the classifier&#39;s results list.</span>
            <span class="n">classifier_results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">)</span>
        <span class="c1"># We add the current amplitude to final_range.</span>
        <span class="n">final_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span>
    <span class="c1"># Now we just return a list containing classifier_results and final_range.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">classifier_results</span><span class="p">,</span> <span class="n">final_range</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">graph_comparison_results</span><span class="p">(</span><span class="n">comparison_results</span><span class="p">,</span>
                             <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This takes in the data that was generated by the get_classifier_comparison_results function, and plots it into a</span>
<span class="sd">    graph comparing classifier results. The reason why these functions are separate is because the</span>
<span class="sd">    get_classifier_comparison_results function takes a lot of time, so if the functions are separated, it becomes a lot</span>
<span class="sd">    easier to quickly modify a plot to one&#39;s liking if</span>
<span class="sd">    the two functionss are in an ipython notebook or something similar.</span>

<span class="sd">    **comparison_results:** The results of the get_classifier_comparison_results function.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># This is for the legend later on.</span>
    <span class="n">graph_handles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># This graphs all of the data in comparison_results.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">comparison_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">graph_handles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comparison_results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">comparison_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Now, we finally just create a legend.</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">graph_handles</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_percent_correct</span><span class="p">(</span><span class="n">expected_values</span><span class="p">,</span> <span class="n">predicted_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in expected and predicted value arrays generated by the predict_data_with_known_type_with_classifier function</span>
<span class="sd">    and returns the percentage of predictions that are correct.</span>

<span class="sd">    **expected_values:** The array containing the expected values for a classifier to predict</span>

<span class="sd">    **predicted_values:** The array containing the values a classifier actually predicted</span>

<span class="sd">    **returns:** A float, from 0.0 to 100.0, that is the percentage of predictions that are correct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gets the amount of values that are correct as a float.</span>
    <span class="c1"># It is a float so that integer division doesn&#39;t happen in the return statement.</span>
    <span class="c1"># A value is considered &quot;correct&quot; if the expected value is the same as the predicted value.</span>
    <span class="n">num_correct</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">val_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_values</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">expected_values</span><span class="p">[</span><span class="n">val_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted_values</span><span class="p">[</span><span class="n">val_index</span><span class="p">]:</span>
            <span class="n">num_correct</span> <span class="o">+=</span> <span class="mf">1.0</span>
    <span class="c1"># Now it just calculates the percent correct and returns it.</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num_correct</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_values</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="Machine_Learning.convert_number_string_to_integer">
    <p>def <span class="ident">convert_number_string_to_integer</span>(</p><p>number_string, max_values)</p>
    </div>
    

    
  
    <div class="desc"><p>This is a small function which is used in some other functions which,
if number_string is an integer within a string, returns that integer,
and if number_string is an indication of percentage, like "tenth" or "seventh" it returns that amount of max_values.
For instance, if "third" is inputted for number_string, and max_values is thirty, 10 would be returned.</p>
<p><strong>number_string:</strong> The string containing the integer or indication of percentage.</p>
<p><strong>max_values:</strong> The maximum amount of values in a dataset or something,
this is used for strings that indicate percentage.</p>
<p><strong>returns:</strong> The integer the number string contains or the integer calculated by the percentage number_string contains.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.convert_number_string_to_integer', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.convert_number_string_to_integer" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">convert_number_string_to_integer</span><span class="p">(</span><span class="n">number_string</span><span class="p">,</span> <span class="n">max_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a small function which is used in some other functions which,</span>
<span class="sd">    if number_string is an integer within a string, returns that integer,</span>
<span class="sd">    and if number_string is an indication of percentage, like &quot;tenth&quot; or &quot;seventh&quot; it returns that amount of max_values.</span>
<span class="sd">    For instance, if &quot;third&quot; is inputted for number_string, and max_values is thirty, 10 would be returned.</span>

<span class="sd">    **number_string:** The string containing the integer or indication of percentage.</span>

<span class="sd">    **max_values:** The maximum amount of values in a dataset or something,</span>
<span class="sd">    this is used for strings that indicate percentage.</span>

<span class="sd">    **returns:** The integer the number string contains or the integer calculated by the percentage number_string contains.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If number_string contains only a number, it returns that number.</span>
    <span class="k">if</span> <span class="n">number_string</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_string</span><span class="p">)</span>
    <span class="c1"># These are the valid indications of percentage to be used.</span>
    <span class="n">string_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;half&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;third&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="s2">&quot;quarter&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="s2">&quot;fifth&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s2">&quot;sixth&quot;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="s2">&quot;seventh&quot;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
        <span class="s2">&quot;eighth&quot;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
        <span class="s2">&quot;ninth&quot;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
        <span class="s2">&quot;tenth&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># If number_string is one of the valid indications of percentage, it returns the number that is that percentage.</span>
    <span class="k">if</span> <span class="n">number_string</span> <span class="ow">in</span> <span class="n">string_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_values</span><span class="o">//</span><span class="n">string_dict</span><span class="p">[</span><span class="n">number_string</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;String inputted does not contain an integer or a valid indication of percentage!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.get_classifier_comparision_results">
    <p>def <span class="ident">get_classifier_comparision_results</span>(</p><p>good_datasets, randomness_amplitude_range, classifiers)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes an array of 'good' datasets, as well as an array of random noise amplitudes to test and classifier types
as keyword arguments, and returns data to be graphed in the graph_comparison_results.
These two functions together will make a graph showing the percentage of guesses that were correct at
different random noise amplitudes for different classifiers. Users can use this to compare the performance
of different classifiers. The reason why these functions are separate is because since this process takes a large
amount of time, so if the functions are separated, it becomes a lot easier to quickly modify a plot to one's liking
if the two functions are in an ipython notebook or something similar.</p>
<p><strong>good_datasets:</strong> An array of good datasets for a single variable.</p>
<p><strong>randomness_amplitude_range:</strong> An array all of the random noise amplitudes to use for "bad" data in tests.</p>
<p><strong>classifiers:</strong> A dictionary containing the classifier's CLASSES, not classifier objects, to test.
Each key must be the name of each classifier.</p>
<p><strong>returns:</strong> Data to be used by the graph_comparison_results.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.get_classifier_comparision_results', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.get_classifier_comparision_results" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_classifier_comparision_results</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">,</span>
                                       <span class="n">randomness_amplitude_range</span><span class="p">,</span>
                                       <span class="n">classifiers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes an array of &#39;good&#39; datasets, as well as an array of random noise amplitudes to test and classifier types</span>
<span class="sd">    as keyword arguments, and returns data to be graphed in the graph_comparison_results.</span>
<span class="sd">    These two functions together will make a graph showing the percentage of guesses that were correct at</span>
<span class="sd">    different random noise amplitudes for different classifiers. Users can use this to compare the performance</span>
<span class="sd">    of different classifiers. The reason why these functions are separate is because since this process takes a large</span>
<span class="sd">    amount of time, so if the functions are separated, it becomes a lot easier to quickly modify a plot to one&#39;s liking</span>
<span class="sd">    if the two functions are in an ipython notebook or something similar.</span>

<span class="sd">    **good_datasets:** An array of good datasets for a single variable.</span>

<span class="sd">    **randomness_amplitude_range:** An array all of the random noise amplitudes to use for &quot;bad&quot; data in tests.</span>

<span class="sd">    **classifiers:** A dictionary containing the classifier&#39;s CLASSES, not classifier objects, to test.</span>
<span class="sd">    Each key must be the name of each classifier.</span>

<span class="sd">    **returns:** Data to be used by the graph_comparison_results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This will contain the results at each point for each classifier.</span>
    <span class="n">classifier_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># This will contain all the amplitudes later.</span>
    <span class="n">final_range</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Each key of classifier_results will be the name of a classifier, and each value will be a list of floats,</span>
    <span class="c1"># each one detailling the percentage of predictions the classifier got correct at a specific point.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">classifier_results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">amplitude</span> <span class="ow">in</span> <span class="n">randomness_amplitude_range</span><span class="p">:</span>
        <span class="c1"># Now we generate an array of bad datasets, from the good ones.</span>
        <span class="c1"># We have to do this manually, since this isn&#39;t an DictionarySystem and we don&#39;t have a function for it.</span>
        <span class="n">bad_datasets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">)):</span>
            <span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">+</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">[</span><span class="n">index</span><span class="p">])))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">new_good_datasets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="c1"># Although the following variable is called &quot;training_data&quot;, we will also be using it for testing.</span>
        <span class="c1"># One half of it will be used to train each classifier, the other half will be used to test each classifier.</span>
        <span class="n">training_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">new_good_datasets</span><span class="p">,</span> <span class="n">bad_datasets</span><span class="p">))</span>
        <span class="c1"># We need to make all of the values positive, since some classifiers</span>
        <span class="c1"># apparently don&#39;t work well with negative values.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">])):</span>
                <span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="n">value</span><span class="p">])</span>
        <span class="c1"># Our target data will simply be &quot;good&quot; and &quot;bad&quot;. At some point, I should probably add a</span>
        <span class="c1"># feature to be able to put in your own data to compare classifiers in non-binary classification,</span>
        <span class="c1"># but right now I am too tired.</span>
        <span class="n">target_data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;good&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_datasets</span><span class="p">)</span>
        <span class="n">target_data</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;bad&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_datasets</span><span class="p">))</span>
        <span class="c1"># To remove bias, we shuffle both the training and target datasets.</span>
        <span class="n">training_data</span><span class="p">,</span> <span class="n">target_data</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">training_data</span><span class="p">,</span> <span class="n">target_data</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># This is the number of datasets, I am just defining this to make it easier in the next part.</span>
        <span class="n">n_sets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">training_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># We have to initialize the current classifier type here, and set it to a variable.</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">key</span><span class="p">]()</span>
            <span class="c1"># Now we train it with half of the data.</span>
            <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_data</span><span class="p">[:</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="n">target_data</span><span class="p">[:</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
            <span class="c1"># This is what a classifier would predict if it got its predictions 100% correct.</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span>
            <span class="c1"># This is what the classifier actually predicted.</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">training_data</span><span class="p">[</span><span class="n">n_sets</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:])</span>
            <span class="c1"># Now, we just add up how many predictions the classifier got right:</span>
            <span class="n">num_correct</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">predicted</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">expected</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
                    <span class="n">num_correct</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># We now use this number to calculate the percentage correct for this classifier</span>
            <span class="c1"># at this random noise amplitude, then add it to the classifier&#39;s results list.</span>
            <span class="n">classifier_results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">num_correct</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted</span><span class="p">)))</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">)</span>
        <span class="c1"># We add the current amplitude to final_range.</span>
        <span class="n">final_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span>
    <span class="c1"># Now we just return a list containing classifier_results and final_range.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">classifier_results</span><span class="p">,</span> <span class="n">final_range</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.get_multiple_data_arrays_as_list">
    <p>def <span class="ident">get_multiple_data_arrays_as_list</span>(</p><p>*data_arrays)</p>
    </div>
    

    
  
    <div class="desc"><p>Since the predict_data_with_known_type_with_classifier function only returns two lists, this function exists to get
a set of multiple data arrays into the same list format as the predict_data_with_known_type_with_classifier function.</p>
<p><strong>data_arrays:</strong> The arrays to turn into a list.</p>
<p><strong>returns:</strong> the combined list of all of the data arrays.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.get_multiple_data_arrays_as_list', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.get_multiple_data_arrays_as_list" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_multiple_data_arrays_as_list</span><span class="p">(</span><span class="o">*</span><span class="n">data_arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Since the predict_data_with_known_type_with_classifier function only returns two lists, this function exists to get</span>
<span class="sd">    a set of multiple data arrays into the same list format as the predict_data_with_known_type_with_classifier function.</span>

<span class="sd">    **data_arrays:** The arrays to turn into a list.</span>

<span class="sd">    **returns:** the combined list of all of the data arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_array_combined_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># This for loop just goes through the data_arrays dictionary and adds all the iterables in it to</span>
    <span class="c1"># data_array_combined_list as numpy arrays.</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">data_array_combined_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data_array_combined_list</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.get_percent_correct">
    <p>def <span class="ident">get_percent_correct</span>(</p><p>expected_values, predicted_values)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes in expected and predicted value arrays generated by the predict_data_with_known_type_with_classifier function
and returns the percentage of predictions that are correct.</p>
<p><strong>expected_values:</strong> The array containing the expected values for a classifier to predict</p>
<p><strong>predicted_values:</strong> The array containing the values a classifier actually predicted</p>
<p><strong>returns:</strong> A float, from 0.0 to 100.0, that is the percentage of predictions that are correct.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.get_percent_correct', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.get_percent_correct" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_percent_correct</span><span class="p">(</span><span class="n">expected_values</span><span class="p">,</span> <span class="n">predicted_values</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes in expected and predicted value arrays generated by the predict_data_with_known_type_with_classifier function</span>
<span class="sd">    and returns the percentage of predictions that are correct.</span>

<span class="sd">    **expected_values:** The array containing the expected values for a classifier to predict</span>

<span class="sd">    **predicted_values:** The array containing the values a classifier actually predicted</span>

<span class="sd">    **returns:** A float, from 0.0 to 100.0, that is the percentage of predictions that are correct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gets the amount of values that are correct as a float.</span>
    <span class="c1"># It is a float so that integer division doesn&#39;t happen in the return statement.</span>
    <span class="c1"># A value is considered &quot;correct&quot; if the expected value is the same as the predicted value.</span>
    <span class="n">num_correct</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">val_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predicted_values</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">expected_values</span><span class="p">[</span><span class="n">val_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">predicted_values</span><span class="p">[</span><span class="n">val_index</span><span class="p">]:</span>
            <span class="n">num_correct</span> <span class="o">+=</span> <span class="mf">1.0</span>
    <span class="c1"># Now it just calculates the percent correct and returns it.</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num_correct</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">predicted_values</span><span class="p">))</span> <span class="o">*</span> <span class="mf">100.0</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.graph_comparison_results">
    <p>def <span class="ident">graph_comparison_results</span>(</p><p>comparison_results, plot_axis=None, **plot_kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>This takes in the data that was generated by the get_classifier_comparison_results function, and plots it into a
graph comparing classifier results. The reason why these functions are separate is because the
get_classifier_comparison_results function takes a lot of time, so if the functions are separated, it becomes a lot
easier to quickly modify a plot to one's liking if
the two functionss are in an ipython notebook or something similar.</p>
<p><strong>comparison_results:</strong> The results of the get_classifier_comparison_results function.</p>
<p><strong>plot_axis:</strong> Optional argument, where a user can specify an axis variable to do matplotlib methods.</p>
<p><strong>plot_kwargs:</strong> keyword arguments to add to the matplotlib plot() method.
Many will not be accepted, but most stylistic arguments will be.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.graph_comparison_results', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.graph_comparison_results" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">graph_comparison_results</span><span class="p">(</span><span class="n">comparison_results</span><span class="p">,</span>
                             <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This takes in the data that was generated by the get_classifier_comparison_results function, and plots it into a</span>
<span class="sd">    graph comparing classifier results. The reason why these functions are separate is because the</span>
<span class="sd">    get_classifier_comparison_results function takes a lot of time, so if the functions are separated, it becomes a lot</span>
<span class="sd">    easier to quickly modify a plot to one&#39;s liking if</span>
<span class="sd">    the two functionss are in an ipython notebook or something similar.</span>

<span class="sd">    **comparison_results:** The results of the get_classifier_comparison_results function.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># This is for the legend later on.</span>
    <span class="n">graph_handles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># This graphs all of the data in comparison_results.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">comparison_results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">graph_handles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comparison_results</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">comparison_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Now, we finally just create a legend.</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">graph_handles</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.make_prediction_graph">
    <p>def <span class="ident">make_prediction_graph</span>(</p><p>trained_classifier, x_axis, data_array, num_lines=&#39;all&#39;, plot_axis=None, z_indexes=None, **plot_kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes a trained classifier and a lot of information and
draws a graph depicting lines that went through the classifier,
with their color indicating what the classifier predicted they were.</p>
<p><strong>trained_classifier:</strong> A trained classifier to be used for predictions of the data specified.</p>
<p><strong>x_axis:</strong> some type of iterable object containing values to be used for
the x values of points in datasets specified by the kwargs.</p>
<p><strong>data_array:</strong> An array containing all the datasets to be tested by the classifier.</p>
<p><strong>num_lines:</strong> the amount of lines to be plotted on the graph. Accepted values are any integer,
the string "all" if you want all lines to be plotted,
and the string "half" if you want half of the lines to be plotted.</p>
<p><strong>plot_axis:</strong> Optional argument, where a user can specify an axis variable to do matplotlib methods.</p>
<p><strong>z_indexes:</strong> a dictionary with keys being all of the kwarg keys,
which contains z indexes for different predicted results.
If not specified or set to None, the default z indexes will be used.</p>
<p><strong>plot_kwargs:</strong> keyword arguments to add to the matplotlib plot() method.
Many will not be accepted, but most stylistic arguments will be.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.make_prediction_graph', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.make_prediction_graph" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_prediction_graph</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span>
                          <span class="n">x_axis</span><span class="p">,</span>
                          <span class="n">data_array</span><span class="p">,</span>
                          <span class="n">num_lines</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                          <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="n">z_indexes</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a trained classifier and a lot of information and</span>
<span class="sd">    draws a graph depicting lines that went through the classifier,</span>
<span class="sd">    with their color indicating what the classifier predicted they were.</span>

<span class="sd">    **trained_classifier:** A trained classifier to be used for predictions of the data specified.</span>

<span class="sd">    **x_axis:** some type of iterable object containing values to be used for</span>
<span class="sd">    the x values of points in datasets specified by the kwargs.</span>

<span class="sd">    **data_array:** An array containing all the datasets to be tested by the classifier.</span>

<span class="sd">    **num_lines:** the amount of lines to be plotted on the graph. Accepted values are any integer,</span>
<span class="sd">    the string &quot;all&quot; if you want all lines to be plotted,</span>
<span class="sd">    and the string &quot;half&quot; if you want half of the lines to be plotted.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **z_indexes:** a dictionary with keys being all of the kwarg keys,</span>
<span class="sd">    which contains z indexes for different predicted results.</span>
<span class="sd">    If not specified or set to None, the default z indexes will be used.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># Now, we shuffle the data_array variable, and use our classifier to get predicted values.</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">data_array</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="c1"># Next, we set some variables to be used later.</span>
    <span class="n">color_types</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">graph_handles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Now, we get the actual amount of lines we need to plot.</span>
    <span class="n">new_num_lines</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">num_lines</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">convert_number_string_to_integer</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_lines must be an integer or a string!&quot;</span><span class="p">)</span>
    <span class="c1"># Now we start going through each line and what the classifier predicted for each one.</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">predicted_value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_list</span><span class="p">)),</span> <span class="n">test_list</span><span class="p">,</span> <span class="n">predicted</span><span class="p">):</span>
        <span class="c1"># If we have gone past the amount of lines we want to graph, we break out of the for loop.</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">new_num_lines</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># Now we check to see if the predicted value for this line has been plotted before,</span>
        <span class="c1"># and therefore already has a color.</span>
        <span class="k">if</span> <span class="n">predicted_value</span> <span class="ow">in</span> <span class="n">color_types</span><span class="p">:</span>
            <span class="c1"># If it does, we check to see if z_indexes is not None.</span>
            <span class="c1"># If it isn&#39;t None, then we give it its assigned z index; otherwise, we leave it at the default.</span>
            <span class="k">if</span> <span class="n">z_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="n">zorder</span><span class="o">=</span><span class="n">z_indexes</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Right now, we have a line that has a predicted value that has not been plotted yet.</span>
            <span class="c1"># Because of this, first we have to plot it:</span>
            <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">z_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                                               <span class="n">zorder</span><span class="o">=</span><span class="n">z_indexes</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                                               <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plotted_stuff</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_axis</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
                                         <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">,</span>
                                         <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
            <span class="c1"># Now, since matplotlib has automatically assigned this line a color,</span>
            <span class="c1"># we add the color to the color_types dictionary,</span>
            <span class="c1"># with it&#39;s key being the predicted value for the current line.</span>
            <span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">plotted_stuff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span>
            <span class="c1"># We also add a handle for this color, for the legend later on.</span>
            <span class="n">graph_handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">mpatches</span><span class="o">.</span><span class="n">Patch</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">color_types</span><span class="p">[</span><span class="n">predicted_value</span><span class="p">],</span>
                               <span class="n">label</span><span class="o">=</span><span class="n">predicted_value</span><span class="p">))</span>
    <span class="c1"># Now we create a legend showing all of the colors of the lines and all of their respective values.</span>
    <span class="c1"># The legend gets added to the side, though I may add functionality to edit it&#39;s location later.</span>
    <span class="n">plot_axis</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">graph_handles</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">1.05</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">borderaxespad</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.plot_variable_array">
    <p>def <span class="ident">plot_variable_array</span>(</p><p>independent_variable_arr, dependent_variable_arr, num_lines=&#39;all&#39;, plot_axis=None, **plot_kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>This function takes two arrays containing lists of values and graphs lines from the information in the arrays.</p>
<p><strong>independent_variable_arr:</strong> a two dimensional array containing lists of values for the x-axis.</p>
<p><strong>dependent_variable_arr:</strong> a two dimensional array containing lists of values for the y-axis.</p>
<p><strong>num_lines:</strong> The amount of lines to be graphed.</p>
<p><strong>plot_axis:</strong> Optional argument, where a user can specify an axis variable to do matplotlib methods.</p>
<p><strong>plot_kwargs:</strong> keyword arguments to add to the matplotlib plot() method.
Many will not be accepted, but most stylistic arguments will be.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.plot_variable_array', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.plot_variable_array" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">plot_variable_array</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">,</span>
                        <span class="n">dependent_variable_arr</span><span class="p">,</span>
                        <span class="n">num_lines</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
                        <span class="n">plot_axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes two arrays containing lists of values and graphs lines from the information in the arrays.</span>

<span class="sd">    **independent_variable_arr:** a two dimensional array containing lists of values for the x-axis.</span>

<span class="sd">    **dependent_variable_arr:** a two dimensional array containing lists of values for the y-axis.</span>

<span class="sd">    **num_lines:** The amount of lines to be graphed.</span>

<span class="sd">    **plot_axis:** Optional argument, where a user can specify an axis variable to do matplotlib methods.</span>

<span class="sd">    **plot_kwargs:** keyword arguments to add to the matplotlib plot() method.</span>
<span class="sd">    Many will not be accepted, but most stylistic arguments will be.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">plot_axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">plot_axis</span> <span class="o">=</span> <span class="n">plt</span>
    <span class="c1"># These are the arguments that are going to be put into plot_axis.plot that can be changed.</span>
    <span class="n">final_plot_args</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lw&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;alpha&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;figure&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ls&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;marker&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mec&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mew&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;mfc&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;ms&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;markevery&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_capstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;solid_joinstyle&quot;</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
        <span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">}</span>
    <span class="c1"># This goes and modifies arguments from the default values of &quot;None&quot; to their respective values in plot_args.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plot_kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">final_plot_args</span><span class="p">:</span>
            <span class="n">final_plot_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="c1"># These lines get the actual amount of lines to graph, since strings can be inputted in num_lines.</span>
    <span class="c1"># It will also raise an error if num_lines is not a valid string or int, so that is just an added bonus!</span>
    <span class="n">new_num_lines</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">num_lines</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">new_num_lines</span> <span class="o">=</span> <span class="n">convert_number_string_to_integer</span><span class="p">(</span><span class="n">num_lines</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_points is not an int or a string!&quot;</span><span class="p">)</span>
    <span class="c1"># Before the function actually graphs lines, it checks to see if the amount of lines the user wants to graph</span>
    <span class="c1"># is bigger than the amount of lines that are possible to be graphed, just in case.</span>
    <span class="k">if</span> <span class="n">new_num_lines</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_num_lines</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dependent_variable_arr</span><span class="p">):</span>
        <span class="c1"># The function plots the amount of lines specified by the function call.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_num_lines</span><span class="p">):</span>
            <span class="n">plot_axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">independent_variable_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dependent_variable_arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">final_plot_args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_lines is bigger than the amount of lines that are possible to graph!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.predict_data_with_classifier">
    <p>def <span class="ident">predict_data_with_classifier</span>(</p><p>trained_classifier, *data_arrays)</p>
    </div>
    

    
  
    <div class="desc"><p>This takes a trained classifier and a variable amount of arrays of data created by
DictionarySystem's get_dataset_variable_values method and returns the predictions of the classifier for the
arrays of data, in a list.</p>
<p><strong>trained_classifier:</strong> A trained classifier.</p>
<p><strong>data_arrays:</strong> Arrays of data created by DictionarySystem's get_dataset_variable_values method.</p>
<p><strong>returns:</strong> predictions of the classifier for the arrays of data,
in the format that the data_arrays arguments was inputted in.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.predict_data_with_classifier', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.predict_data_with_classifier" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict_data_with_classifier</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span> <span class="o">*</span><span class="n">data_arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This takes a trained classifier and a variable amount of arrays of data created by</span>
<span class="sd">    DictionarySystem&#39;s get_dataset_variable_values method and returns the predictions of the classifier for the</span>
<span class="sd">    arrays of data, in a list.</span>

<span class="sd">    **trained_classifier:** A trained classifier.</span>

<span class="sd">    **data_arrays:** Arrays of data created by DictionarySystem&#39;s get_dataset_variable_values method.</span>

<span class="sd">    **returns:** predictions of the classifier for the arrays of data,</span>
<span class="sd">    in the format that the data_arrays arguments was inputted in.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Since I want this to be as open ended as possible,</span>
        <span class="c1"># I am trying to allow people to input multiple arrays of data.</span>
        <span class="c1"># Because of this, since more than one value in data_arrays was inputted,</span>
        <span class="c1"># we first need to go through all of the arrays of data and add them to a universal testing_data list.</span>
        <span class="c1"># Also, technically, they don&#39;t have to be arrays, but I would like them to be.</span>
        <span class="n">testing_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="n">testing_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>
        <span class="c1"># Now, it just predicts and returns the predicted data.</span>
        <span class="n">result_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># I prefer going through lists with numerical indexes, so I did that,</span>
        <span class="c1"># but this can easily be changed if it needs to be.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">testing_data</span><span class="p">)):</span>
            <span class="n">result_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">testing_data</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result_list</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Well, if we have a single argument inputted, we don&#39;t want to be returning a single value list,</span>
        <span class="c1"># so this is intended to stop that from happening. I won&#39;t comment anything else in this part because</span>
        <span class="c1"># it is basically a simplified version of the above code.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument inputted that is not an array, list, or other Iterable!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.predict_data_with_known_type_with_classifier">
    <p>def <span class="ident">predict_data_with_known_type_with_classifier</span>(</p><p>trained_classifier, **data_dictionary)</p>
    </div>
    

    
  
    <div class="desc"><p>This function does the same thing as the predict_data_with_classifier function,
except returns two lists: expected and predicted. expected contains the actual type of each dataset,
and predicted contains the predicted type of each dataset.</p>
<p><strong>trained_classifier:</strong> a trained classifier</p>
<p><strong>data_dictionary:</strong> keyword arguments with the keys containing the prediction values and
the values being an arrays of datasets created by DictionarySystem's get_dataset_variable_values method</p>
<p><strong>returns:</strong> a tuple containing the expected array first and the predicted array second.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.predict_data_with_known_type_with_classifier', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.predict_data_with_known_type_with_classifier" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">predict_data_with_known_type_with_classifier</span><span class="p">(</span><span class="n">trained_classifier</span><span class="p">,</span> <span class="o">**</span><span class="n">data_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function does the same thing as the predict_data_with_classifier function,</span>
<span class="sd">    except returns two lists: expected and predicted. expected contains the actual type of each dataset,</span>
<span class="sd">    and predicted contains the predicted type of each dataset.</span>

<span class="sd">    **trained_classifier:** a trained classifier</span>

<span class="sd">    **data_dictionary:** keyword arguments with the keys containing the prediction values and</span>
<span class="sd">    the values being an arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method</span>

<span class="sd">    **returns:** a tuple containing the expected array first and the predicted array second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Before I start explaining everything, I want to say that, for certain reasons, this function does not retain the</span>
    <span class="c1"># structure of data_dictionary like the predict_data_with_classifier does. It simply returns two lists: expected,</span>
    <span class="c1"># and predicted, because I couldn&#39;t figure out how to do anything else. If somebody needs to get their original</span>
    <span class="c1"># data into a list of the same format, they can use the get_multiple_data_arrays_as_list function.</span>
    <span class="c1">#</span>
    <span class="c1"># Alright, so this following part is basically a copy-pasted version of code in the train_classifier function,</span>
    <span class="c1"># so if you do not understand this, I recommend you go there.</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">value_as_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">test_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">)</span>
            <span class="n">expected</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keyword argument has been inputted that is not an array or iterable&quot;</span><span class="p">)</span>
    <span class="c1"># We now turn the two lists into arrays, and shuffle them:</span>
    <span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span>
    <span class="n">test_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="n">test_list</span><span class="p">,</span> <span class="n">expected</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Next we use the classifier to predict the data.</span>
    <span class="n">predicted</span> <span class="o">=</span> <span class="n">trained_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_list</span><span class="p">)</span>
    <span class="c1"># Finally, we return both lists.</span>
    <span class="k">return</span> <span class="n">expected</span><span class="p">,</span> <span class="n">predicted</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.split_csv_by_column">
    <p>def <span class="ident">split_csv_by_column</span>(</p><p>path, column)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes a path to a csv file, loads it as a pandas dataframe, splits it by a column,
and returns the resulting DictionarySystem.</p>
<p><strong>path:</strong> The path to a csv file.</p>
<p><strong>column:</strong> The column to split the pandas dataframe by.</p>
<p><strong>returns:</strong> A DictionarySystem that is the result of splitting the
table contained in the csv file specified by the column specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.split_csv_by_column', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.split_csv_by_column" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_csv_by_column</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a csv file, loads it as a pandas dataframe, splits it by a column,</span>
<span class="sd">    and returns the resulting DictionarySystem.</span>

<span class="sd">    **path:** The path to a csv file.</span>

<span class="sd">    **column:** The column to split the pandas dataframe by.</span>

<span class="sd">    **returns:** A DictionarySystem that is the result of splitting the</span>
<span class="sd">    table contained in the csv file specified by the column specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_table_by_column</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.split_csv_by_columns">
    <p>def <span class="ident">split_csv_by_columns</span>(</p><p>path, *columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes a path to a csv file, loads it as a pandas dataframe, splits it by multiple columns,
and returns the resulting DictionarySystem.</p>
<p><strong>path:</strong> The path to a csv file.</p>
<p><strong>columns:</strong> The columns to split the pandas dataframe by.</p>
<p><strong>returns:</strong> A DictionarySystem that is the result of splitting the
table contained in the csv file specified by the columns specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.split_csv_by_columns', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.split_csv_by_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_csv_by_columns</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a path to a csv file, loads it as a pandas dataframe, splits it by multiple columns,</span>
<span class="sd">    and returns the resulting DictionarySystem.</span>

<span class="sd">    **path:** The path to a csv file.</span>

<span class="sd">    **columns:** The columns to split the pandas dataframe by.</span>

<span class="sd">    **returns:** A DictionarySystem that is the result of splitting the</span>
<span class="sd">    table contained in the csv file specified by the columns specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pandas_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_table_by_columns</span><span class="p">(</span><span class="n">pandas_dataframe</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.split_table_by_column">
    <p>def <span class="ident">split_table_by_column</span>(</p><p>table, column)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes a pandas DataFrame and splits it by column values into a DictionarySystem.</p>
<p><strong>table:</strong> The Dataframe to split into a DictionarySystem.</p>
<p><strong>column:</strong> The column to split the pandas DataFrame by.</p>
<p><strong>returns:</strong> A DictionarySystem created by splitting the pandas DataFrame inputted by the column inputted</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.split_table_by_column', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.split_table_by_column" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_table_by_column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas DataFrame and splits it by column values into a DictionarySystem.</span>

<span class="sd">    **table:** The Dataframe to split into a DictionarySystem.</span>

<span class="sd">    **column:** The column to split the pandas DataFrame by.</span>

<span class="sd">    **returns:** A DictionarySystem created by splitting the pandas DataFrame inputted by the column inputted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Goes through every unique value in the specified column of the the table inputted</span>
    <span class="n">unique_column_vals</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_column_vals</span><span class="p">:</span>
        <span class="c1"># Adds to the dictionary a new table with every value in the</span>
        <span class="c1"># specified column being the current unique value from the for loop.</span>
        <span class="n">table_dictionary</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">table_dictionary</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.split_table_by_columns">
    <p>def <span class="ident">split_table_by_columns</span>(</p><p>table, *columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Takes a pandas DataFrame and splits it by all of the columns specified into a DictionarySystem</p>
<p><strong>table:</strong> The Dataframe to split into a DictionarySystem.</p>
<p><strong>columns:</strong> The columns to split the pandas DataFrame by.</p>
<p><strong>returns:</strong> A DictionarySystem created by splitting the pandas DataFrame inputted by the columns inputted</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.split_table_by_columns', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.split_table_by_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_table_by_columns</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Takes a pandas DataFrame and splits it by all of the columns specified into a DictionarySystem</span>

<span class="sd">    **table:** The Dataframe to split into a DictionarySystem.</span>

<span class="sd">    **columns:** The columns to split the pandas DataFrame by.</span>

<span class="sd">    **returns:** A DictionarySystem created by splitting the pandas DataFrame inputted by the columns inputted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Raises a ValueError if no columns are inputted:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># Splits the table by the first column:</span>
    <span class="n">dictionary_system</span> <span class="o">=</span> <span class="n">split_table_by_column</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># If more than one column was specified, split the DictionarySystem by the extra columns as well.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">dictionary_system</span><span class="o">.</span><span class="n">split_by_columns</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">dictionary_system</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="Machine_Learning.train_classifier">
    <p>def <span class="ident">train_classifier</span>(</p><p>classifier_type=&#39;Random Forest&#39;, **data_dictionary)</p>
    </div>
    

    
  
    <div class="desc"><p>Accepts arrays of datasets created by DictionarySystem's get_dataset_variable_values method and
returns a classifier that has been trained off of the data specified.</p>
<p><strong>classifier_type:</strong> The type of classifier to be trained.
A classifier CLASS (not object) can be inputted,
or a string can be inputted with the name of the classifiers;
keep in mind this does not work for every classifier available, but a lot of classifiers are valid.</p>
<p><strong>data_dictionary:</strong> keyword arguments with the keys containing the prediction values and
the values being an arrays of datasets created by DictionarySystem's get_dataset_variable_values method</p>
<p><strong>returns:</strong> a classifier that has been trained off of the data specified.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.train_classifier', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.train_classifier" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">train_classifier</span><span class="p">(</span><span class="n">classifier_type</span><span class="o">=</span><span class="s1">&#39;Random Forest&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">data_dictionary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accepts arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method and</span>
<span class="sd">    returns a classifier that has been trained off of the data specified.</span>

<span class="sd">    **classifier_type:** The type of classifier to be trained.</span>
<span class="sd">    A classifier CLASS (not object) can be inputted,</span>
<span class="sd">    or a string can be inputted with the name of the classifiers;</span>
<span class="sd">    keep in mind this does not work for every classifier available, but a lot of classifiers are valid.</span>

<span class="sd">    **data_dictionary:** keyword arguments with the keys containing the prediction values and</span>
<span class="sd">    the values being an arrays of datasets created by DictionarySystem&#39;s get_dataset_variable_values method</span>

<span class="sd">    **returns:** a classifier that has been trained off of the data specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">clf</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">classifier_type</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="c1"># I am importing inside the function since these will only be used in the specific circumstance that</span>
        <span class="c1"># a user inputted a string for classifier_type.</span>
        <span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="kn">import</span> <span class="n">QuadraticDiscriminantAnalysis</span>
        <span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="kn">import</span> <span class="n">GaussianNB</span><span class="p">,</span> <span class="n">BernoulliNB</span><span class="p">,</span> <span class="n">MultinomialNB</span>
        <span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
        <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
        <span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">RidgeClassifier</span><span class="p">,</span> <span class="n">SGDClassifier</span><span class="p">,</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">,</span> <span class="n">Perceptron</span>
        <span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
        <span class="c1"># A giant dictionary of classifiers in case the user inputted a string for classifier_type:</span>
        <span class="n">classifiers</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;randomforest&quot;</span><span class="p">:</span> <span class="n">RandomForestClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;quadraticdiscriminantanalysis&quot;</span><span class="p">:</span> <span class="n">QuadraticDiscriminantAnalysis</span><span class="p">(),</span>
            <span class="s2">&quot;gaussiannb&quot;</span><span class="p">:</span> <span class="n">GaussianNB</span><span class="p">(),</span>
            <span class="s2">&quot;gaussiannaivebayes&quot;</span><span class="p">:</span> <span class="n">GaussianNB</span><span class="p">(),</span>
            <span class="s2">&quot;bernoullinb&quot;</span><span class="p">:</span> <span class="n">BernoulliNB</span><span class="p">(),</span>
            <span class="s2">&quot;bernoullinaivebayes&quot;</span><span class="p">:</span> <span class="n">BernoulliNB</span><span class="p">(),</span>
            <span class="s2">&quot;multinomialnb&quot;</span><span class="p">:</span> <span class="n">MultinomialNB</span><span class="p">(),</span>
            <span class="s2">&quot;multinomialnaivebayes&quot;</span><span class="p">:</span> <span class="n">MultinomialNB</span><span class="p">(),</span>
            <span class="s2">&quot;decisiontree&quot;</span><span class="p">:</span> <span class="n">DecisionTreeClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;ridge&quot;</span><span class="p">:</span> <span class="n">RidgeClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;sgd&quot;</span><span class="p">:</span> <span class="n">SGDClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;stochasticgradientdescent&quot;</span><span class="p">:</span> <span class="n">SGDClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;passiveaggressive&quot;</span><span class="p">:</span> <span class="n">PassiveAggressiveClassifier</span><span class="p">(),</span>
            <span class="s2">&quot;perceptron&quot;</span><span class="p">:</span> <span class="n">Perceptron</span><span class="p">(),</span>
            <span class="s2">&quot;svc&quot;</span><span class="p">:</span> <span class="n">SVC</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="c1"># Now, because people can type things in in different ways,</span>
        <span class="c1"># we try to make this string system as fool-proof as possible!</span>
        <span class="c1"># First, we set all the characters to lower case:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">classifier_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># Then we remove all underscores and spaces:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">formatted_classifier_type</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s2">&quot; _&quot;</span><span class="p">)</span>
        <span class="c1"># Then we remove all instances of the word &quot;classifier&quot;:</span>
        <span class="n">formatted_classifier_type</span> <span class="o">=</span> <span class="n">formatted_classifier_type</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;classifier&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="c1"># Now, we check to see if they actually inputted a classifier we know! If they didn&#39;t, we raise a ValueError.</span>
        <span class="k">if</span> <span class="n">formatted_classifier_type</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">:</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">formatted_classifier_type</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Classifier name inputted is not a supported classifier type!&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># So what would happen if the individual inputted their own classifier type for a classifier?</span>
        <span class="c1"># Well, this covers that! Using the check_estimator function, we can tell if the inputted classifier is valid,</span>
        <span class="c1"># and raise an error if it isn&#39;t.</span>
        <span class="c1"># Keep in mind I am importing this here because if the user never inputs a classifier&#39;s class for</span>
        <span class="c1"># classifier_type, this import would never be used.</span>
        <span class="kn">from</span> <span class="nn">sklearn.utils.estimator_checks</span> <span class="kn">import</span> <span class="n">check_estimator</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">check_estimator</span><span class="p">(</span><span class="n">classifier_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyboardInterrupt</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Estimator inputted is not a valid estimator, &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;use sklearn&#39;s check_estimator function for more information!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clf</span> <span class="o">=</span> <span class="n">classifier_type</span><span class="p">()</span>
    <span class="c1"># Now we need to get our data in the correct format! First, we define two lists:</span>
    <span class="c1"># the training list which will contain the data,</span>
    <span class="c1"># and the target list which will contain what value each dataset is supposed to be.</span>
    <span class="n">training_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">target_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Now we iterate through our keyword arguments, to add values to these two lists.</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data_dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
        <span class="c1"># If the value at the current key is a numpy array, we just add all of it&#39;s values to the training list,</span>
        <span class="c1"># and it&#39;s key multiple times to the target list.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="c1"># We do the same thing with the list.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="c1"># If the value at the current key is another form of iterable, we convert it to a list and do the same thing.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">value_as_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">training_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">)</span>
            <span class="n">target_list</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">value_as_list</span><span class="p">))</span>
        <span class="c1"># If the value is not any type of iterable, we raise a ValueError.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;keyword argument has been inputted that is not an array or iterable&quot;</span><span class="p">)</span>
    <span class="c1"># Now we convert both lists to arrays, because they must be arrays to be put through the classifier.</span>
    <span class="n">training_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">training_list</span><span class="p">)</span>
    <span class="n">target_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_list</span><span class="p">)</span>
    <span class="c1"># To make sure no bias appears in the classifier, we shuffle both of the arrays in the same way.</span>
    <span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span> <span class="o">=</span> <span class="n">shuffle</span><span class="p">(</span><span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Finally, we fit the classifier and return it.</span>
    <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_arr</span><span class="p">,</span> <span class="n">target_arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">clf</span>
</pre></div>

  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="Machine_Learning.DictionarySystem" class="name">class <span class="ident">DictionarySystem</span></p>
      
  
    <div class="desc"><p>DictionarySystem is a class that contains a nested dictionary that has data that has been split by
unique values of one or more variables. It is used to format and interpolate data,
as well as generate entirely new data.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DictionarySystem</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;DictionarySystem is a class that contains a nested dictionary that has data that has been split by</span>
<span class="sd">    unique values of one or more variables. It is used to format and interpolate data,</span>
<span class="sd">    as well as generate entirely new data.&quot;&quot;&quot;</span>
    <span class="c1"># Functions:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basedict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To initialize a DictionarySystem,</span>
<span class="sd">        a nested dictionary must be inputted with the same format that a DictionarySystem uses.</span>

<span class="sd">        An easy way to create a DictionarySystem is to use any of the following 4 functions:</span>

<span class="sd">        * split_table_by_column</span>
<span class="sd">        * split_table_by_columns</span>
<span class="sd">        * split_csv_by_column</span>
<span class="sd">        * split_csv_by_columns</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Raises an error if basedict is not a dictionary.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;basedict must be a dictionary!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># Checks the validity of basedict. If basedict does not have the correct format,</span>
            <span class="c1"># or has value types that are not DictionarySystems, dictionaries,</span>
            <span class="c1"># or pandas Dataframes, raises a ValueError.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_dictionary_validity</span><span class="p">(</span><span class="n">basedict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">basedict</span>
                <span class="c1"># Converts all sub-dictionaries into DictionarySystems to</span>
                <span class="c1"># allow all of the recursive methods to work.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basedict is not in a valid format, or has invalid value types!&quot;</span><span class="p">)</span>
        <span class="c1"># This is just in case something goes dreadfully wrong, but hopefully it will never be called.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alright, I don&#39;t know what you even did, but something is wrong with basedict.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># This is made to only accept DictionarySystems, dictionaries, and pandas DataFrames,</span>
        <span class="c1"># or else it will throw an error. I am sure you can figure this method out.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value set is not a dictionary or pandas dataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;DictionarySystem(&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;)&quot;</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1"># Old Dictionary Methods:</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns the keys of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a value for a given key inside the DictionarySystem&#39;s dictionary.</span>

<span class="sd">        **key:** the key to be searched in the dictionary.</span>

<span class="sd">        **default:** The value to be returned in case the key specified does not exist.</span>

<span class="sd">        **returns:** the value for the given key in side the FDictionarySystem&#39;s dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pops the value at the given key from the DictionarySystem&#39;s dictionary and returns it.</span>

<span class="sd">        **key:** The key to pop the value from</span>

<span class="sd">        **default:** If the given key does not exist within the DictionarySystem&#39;s dictionary,</span>
<span class="sd">        this value will be returned.</span>

<span class="sd">        **returns:** The value that was just popped from the given key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns the key,value pairs of the DictionarySystem&#39;s dictionary in tuples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This returns a list of all the values in the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iteritems method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iterkeys method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the itervalues method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span>

    <span class="c1"># Table Methods:</span>
    <span class="k">def</span> <span class="nf">split_by_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the dictionary system&#39;s tables by a single column,</span>
<span class="sd">        making the location where the table was a dictionary containing unique column values in the column as keys,</span>
<span class="sd">        with each key containing a table.</span>

<span class="sd">        **column:** The column to split the dictionary systems by.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at that key is a DictionarySystem it calls split_by_column on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="c1"># If the value at that key is a pandas DataFrame it tries to split it:</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># If the column specified is not in the DataFrame, the method raises a KeyError.</span>
                <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Column Specified is not in a table!&quot;</span><span class="p">)</span>
                <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="c1"># The method goes through all of the unique values in the column in the table,</span>
                <span class="c1"># creates new DataFrames containing only the unique value specified, and adds them to a dictionary.</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
                <span class="c1"># The dictionary is then set to be the new value of the key.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dict</span><span class="p">)</span>
            <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
            <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem contains values other than DictionarySystems and tables!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_by_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the same thing as the split_by_column method, except splits by multiple columns in order instead of one.</span>

<span class="sd">        **columns:** The names of each column to split the tables by.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no columns are specified, the method raises a ValueError</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
        <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
        <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
        <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
        <span class="c1"># Jeez, I just realized that like 90% of this entire method is error checking.</span>
        <span class="c1"># Anyway, this now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
        <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
        <span class="c1"># and the method would be okay with it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># finally, after all that error checking, the method goes through the columns_flattened list in order, and</span>
        <span class="c1"># calls split_by_column with each column.</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_column_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all rows that have a duplicate value in a specific column</span>
<span class="sd">        except one in every table in the DictionarySystem,</span>
<span class="sd">        so that no duplicates in the said column will remain in the DictionarySystem.</span>

<span class="sd">        The way this removes columns is by going through each DataFrame in the DictionarySystem, and,</span>
<span class="sd">        for each DataFrame, a new DataFrame is created containing the first rows containing unique values in the initial</span>
<span class="sd">        DataFrame. The old DataFrame is then overwritten.</span>

<span class="sd">        **column:** The column used to remove duplicate values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_column_duplicates on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_column_duplicates</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
            <span class="c1"># otherwise, if the value at the current key is a pandas DataFrame, it starts removing column duplicates.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># It sets the variable new_dataframe to none since I didn&#39;t want the variable to be local to</span>
                <span class="c1"># the for loop and I couldn&#39;t figure out any other way to do that.</span>
                <span class="n">new_dataframe</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="c1"># The method goes through all the unique values of the column specified.</span>
                <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                    <span class="c1"># Inside the for loop, the method creates a new DataFrame containing all the rows where the value</span>
                    <span class="c1"># in the specified column is the same as the for loop&#39;s unique value. It then selects the first</span>
                    <span class="c1"># row in that DataFrame and adds it to the new_dataframe variable. The result at the end of the</span>
                    <span class="c1"># for loop is a new dataframe where duplicate values in the specified column have been removed.</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">new_dataframe</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">new_dataframe</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]])</span>
                <span class="c1"># Finally the method just resets the index of this new DataFrame and sets the value at the current key</span>
                <span class="c1"># to be the new DataFrame with duplicate values removed, replacing the old DataFrame.</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dataframe</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
            <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">remove_short_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_count</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all tables in the DictionarySystem that are below a certain row count.</span>

<span class="sd">        **row_count:** The row count required for a table to stay in the DictionarySystem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_short_tables on that.</span>
            <span class="c1"># If the DictionarySystem has no tables left in it after that, the method deletes the current key.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_short_tables</span><span class="p">(</span><span class="n">row_count</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is a pandas DataFrame and it&#39;s row count is</span>
            <span class="c1"># less than the specified minimum row count, the method deletes the current key.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row_count</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
            <span class="c1"># the method raises a ValueError.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keep_only_certain_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes all columns in every table except the ones specified.</span>
<span class="sd">        This is generally used to remove irrelevant data from tables.</span>

<span class="sd">        **columns:** The names of the columns to keep in every table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no columns are specified, the method raises a ValueError</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
        <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
        <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
        <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
        <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
        <span class="c1"># The method now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
        <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
        <span class="c1"># and the method would be okay with it.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
        <span class="c1"># Now, most of the error checking is done, so the method starts</span>
        <span class="c1"># going through the keys in the DictionarySystem.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a DictionarySystem,</span>
            <span class="c1"># the keep_only_certain_columns method is called on that.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keep_only_certain_columns</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span>
            <span class="c1"># If the value a the current key is a DataFrame, the method sets the value at the current key to a new</span>
            <span class="c1"># DataFrame that only has the columns specified.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">columns_flattened</span><span class="p">]</span>
            <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
            <span class="c1"># the method will raise an error.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>

    <span class="c1"># Array Methods:</span>
    <span class="k">def</span> <span class="nf">interpolate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">num_points</span><span class="p">,</span>
                         <span class="n">independent_variable</span><span class="p">,</span>
                         <span class="n">dependent_variables</span><span class="p">,</span>
                         <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates independent and dependent variables in datasets within the DictionarySystem to have the amount</span>
<span class="sd">        of points specified. Unfortunately, columns that are not the independent or dependent variables will be removed,</span>
<span class="sd">        since they are not being interpolated and the dataframe has to stay rectangular.</span>

<span class="sd">        The independent variable must not have repeat values, and must be increasing. If these two requirements are not</span>
<span class="sd">        fulfilled, the method will fail.</span>

<span class="sd">        **num_points:** The amount of points the dependent variables will be interpolated to.</span>

<span class="sd">        **independent_variable:** The name of the independent variable of the dataset.</span>
<span class="sd">        All values of this variable must be increasing, and no duplicate values can exist.</span>

<span class="sd">        **dependent_variables:** An iterable containing the names of the dependent variables of the dataset.</span>

<span class="sd">        **interpolation_kind:** The kind of interpolation to be used. This will be fed into scipy&#39;s interp1d method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is easy to work with, we actually interpolate our data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                     <span class="n">num_points</span><span class="p">,</span>
                                                     <span class="n">independent_variable</span><span class="p">,</span>
                                                     <span class="n">dependent_variables</span><span class="p">,</span>
                                                     <span class="n">interpolation_kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
        <span class="c1"># Now that our data is interpolated, we convert all of the dictionaries containing</span>
        <span class="c1"># arrays representing columns back to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># We replace our object&#39;s dictionary with the newly interpolated one.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">nested_dictionaries</span>
        <span class="c1"># Now we simply convert all sub-dictionaries to DictionarySystems</span>
        <span class="c1"># to get everything back into the correct format.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">make_fake_data_system_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">independent_var</span><span class="p">,</span>
                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                    <span class="n">num_datasets</span><span class="p">,</span>
                                    <span class="n">location</span><span class="p">,</span>
                                    <span class="n">randomness_amplitudes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to</span>
<span class="sd">        the dependent variables of real datasets.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not have random noise added to it.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        These will have random noise added to their values to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to create</span>

<span class="sd">        **location:** The location to generate fake data at.</span>

<span class="sd">        **randomness_amplitudes** An iterable containing the random noise amplitudes for the random noise to be</span>
<span class="sd">        added to the values for each dependent variable.</span>

<span class="sd">        **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
        <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
        <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                        <span class="n">independent_var</span><span class="p">,</span>
                                                                        <span class="n">dependent_vars</span><span class="p">,</span>
                                                                        <span class="n">num_datasets</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="p">,</span>
                                                                        <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
        <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">make_fake_data_system_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">independent_var</span><span class="p">,</span>
                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                    <span class="n">num_datasets</span><span class="p">,</span>
                                    <span class="n">location</span><span class="p">,</span>
                                    <span class="n">starting_noises</span><span class="p">,</span>
                                    <span class="n">slope_deviations</span><span class="p">,</span>
                                    <span class="n">smoothing_fracs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to the</span>
<span class="sd">        first points of already existing datasets then adding random noise to the slopes between points of existing</span>
<span class="sd">        datasets and creating new points based off of those. After all this is done, a smoothing filter is applied to</span>
<span class="sd">        make the generated lines less jagged.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not be modified during fake data creation.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to be generated.</span>

<span class="sd">        **location:** The location to get datasets to be used to generate new datasets.</span>

<span class="sd">        **starting_noises:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        each dependent variable in existing datasets to generate new datasets.</span>

<span class="sd">        **slope_deviations:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        the slopes of the lines for each dependent variable to generate new datasets.</span>

<span class="sd">        **smoothing_fracs:** An Iterable containing the smoothing fracs for the lowess filter to apply to the</span>
<span class="sd">        generated lines for each dependent variable.</span>

<span class="sd">        **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
        <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
        <span class="c1"># containing arrays representing columns.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
        <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
        <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                        <span class="n">independent_var</span><span class="p">,</span>
                                                                        <span class="n">dependent_vars</span><span class="p">,</span>
                                                                        <span class="n">num_datasets</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="p">,</span>
                                                                        <span class="n">starting_noises</span><span class="p">,</span>
                                                                        <span class="n">slope_deviations</span><span class="p">,</span>
                                                                        <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
        <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
        <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_dataset_variable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_variable</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This gets all of the values for a single variable, and returns them in an array containing lists containing the</span>
<span class="sd">        datapoints for the variable for a single dataset. This is used by a lot of methods, and in general is a format</span>
<span class="sd">        that is somewhat easy to work with.</span>

<span class="sd">        **dataset_variable:** The name of the variable to get all of the values for.</span>

<span class="sd">        **location:** The location to get the variable values from. If it is none, all of the values for the variable</span>
<span class="sd">        will be gotten.</span>

<span class="sd">        **returns:** All of the values of a single variable in an array, with the values being seperated into lists</span>
<span class="sd">        containing the values for a single dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
        <span class="n">dataset_variable_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dataset_variable_values</span>

    <span class="c1"># Array Helper Methods:</span>
    <span class="k">def</span> <span class="nf">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                        <span class="n">dictionary</span><span class="p">,</span>
                                                        <span class="n">dataset_variable</span><span class="p">,</span>
                                                        <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method used by the get_dataset_variable_values method that actually gets the values of the variables for</span>
<span class="sd">        each dataset and outputs them in the right format. This method uses recursion so it had to be seperate from the</span>
<span class="sd">        other method.</span>

<span class="sd">        **dictionary:** The dictionary to get the values of the variables for each dataset from.</span>

<span class="sd">        **dataset_variable:** The name of the variable to get values from.</span>

<span class="sd">        **location:** The location to get the data from. If location is none, it will get dataset variable values</span>
<span class="sd">        from the entire dictionary.</span>

<span class="sd">        **returns** An array containing lists containing the values for a specific variable in each dataset,</span>
<span class="sd">        at the specified location.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no location was inputted, it simply gets all of the dataset</span>
        <span class="c1"># variable values in every dataset and returns an array of those.</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># This list will contain the list of values of the dataset variable for every dataset in</span>
            <span class="c1"># the DictionarySystem.</span>
            <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># If the value at the first key in the current dictionary is an array,</span>
                <span class="c1"># it adds the array whose key is the dataset variable name to variable_set_list</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="c1"># if the current location is an DictionarySystem that contains DictionarySystems representing</span>
                <span class="c1"># individual datasets, it goes through them calls get_dataset_variable_values to each one,</span>
                <span class="c1"># then adds them all to variable_set_list.</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">key_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="o">=</span><span class="p">[])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                <span class="c1"># if the current location is higher up in the nesting, the method calls get_dataset_variable_values on</span>
                <span class="c1"># the DictionarySystem at the current location and adds the results to variable_set_list.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                                                       <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                       <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_results</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_results</span><span class="p">)</span>
            <span class="c1"># Finally, variable_set_list is returned as an array.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
        <span class="c1"># Since location can also be a string, if it is, it checks to see if location is an empty string.</span>
        <span class="c1"># If location is an empty string, it calls get_dataset_variable_values with location being an empty tuple.</span>
        <span class="c1"># If location is not an empty string, it calls get_dataset_variable_values with location being a</span>
        <span class="c1"># single value tuple with the only value being the string that was just passed to location.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                            <span class="n">dataset_variable</span><span class="p">,</span>
                                                                            <span class="n">location</span><span class="o">=</span><span class="p">[])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                        <span class="n">dataset_variable</span><span class="p">,</span>
                                                                        <span class="n">location</span><span class="o">=</span><span class="p">[</span><span class="n">location</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># If location is an iterable, but not a string, then that means we are looking at some sort of path.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="c1"># If the length of location is 0, then that means that the current location is the location to</span>
            <span class="c1"># get the dataset variable&#39;s values from, so we go through the DictionarySystem at the current location</span>
            <span class="c1"># and add all of the values of the dataset variable to a list, then return it as an array.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
            <span class="c1"># If the length of location is 1 then we can do the same thing as when location is 0 with a bit of tweaking.</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">variable_set_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">variable_set_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">][</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">variable_set_list</span><span class="p">)</span>
            <span class="c1"># If the length of location is greater than one then we just use recursion to our advantage.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                            <span class="n">dataset_variable</span><span class="p">,</span>
                                                                            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># If location is not None, a string, or an Iterable, we raise a ValueError.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;location must be an Iterable!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">independent_var</span><span class="p">,</span>
                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                <span class="n">location</span><span class="p">,</span>
                                                <span class="n">starting_noises</span><span class="p">,</span>
                                                <span class="n">slope_deviations</span><span class="p">,</span>
                                                <span class="n">smoothing_fracs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method used by the make_fake_data_system_slope method to generate fake data. This method is seperate from</span>
<span class="sd">        that method because this method requires the use of recursion.</span>

<span class="sd">        **dictionary:** The dictionary that will be used as a reference for the fake data generation.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not be modified during fake data creation.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to be generated.</span>

<span class="sd">        **location:** The location to get datasets to be used to generate new datasets.</span>

<span class="sd">        **starting_noises:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        each dependent variable in existing datasets to generate new datasets.</span>

<span class="sd">        **slope_deviations:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">        the slopes of the lines for each dependent variable to generate new datasets.</span>

<span class="sd">        **smoothing_fracs:** An Iterable containing the smoothing fracs for the lowess filter to apply to the</span>
<span class="sd">        generated lines for each dependent variable.</span>

<span class="sd">        **returns:** A nested dictionary containing the newly generated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">fake_set_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">):</span>
                    <span class="c1"># Copying a random dataset in our already existing datasets,</span>
                    <span class="c1"># which will be modified to become fake data.</span>
                    <span class="n">new_set_values</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
                    <span class="c1"># This will go through each dependent variable&#39;s datapoints and modify them.</span>
                    <span class="k">for</span> <span class="n">dep_var_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dependent_vars</span><span class="p">)):</span>
                        <span class="c1"># This is the array of the old points from an existing dataset.</span>
                        <span class="n">dep_var_values</span> <span class="o">=</span> <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_vars</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">]]</span>
                        <span class="n">new_dep_var_points</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="c1"># This adds a random value to the starting value of dep_var_values,</span>
                        <span class="c1"># creating the first point in our fake dataset.</span>
                        <span class="n">starting_value</span> <span class="o">=</span> <span class="n">dep_var_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">starting_noises</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">])</span>
                        <span class="n">new_dep_var_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">starting_value</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">set_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dep_var_values</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="c1"># We need to modify the slope, so we first have to get the slope.</span>
                            <span class="c1"># To do this, we first have to get the change in the x value:</span>
                            <span class="n">delta_x</span> <span class="o">=</span> <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">][</span><span class="n">set_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>\
                                      <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">][</span><span class="n">set_index</span><span class="p">]</span>
                            <span class="c1"># We also need to get the change in the y value:</span>
                            <span class="n">delta_y</span> <span class="o">=</span> <span class="n">dep_var_values</span><span class="p">[</span><span class="n">set_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dep_var_values</span><span class="p">[</span><span class="n">set_index</span><span class="p">]</span>
                            <span class="c1"># Now we simply calculate the slope:</span>
                            <span class="n">segment_slope</span> <span class="o">=</span> <span class="n">delta_y</span> <span class="o">/</span> <span class="n">delta_x</span>
                            <span class="c1"># We then add a random value to the slope,</span>
                            <span class="c1"># and use our new slope to calculate the next point.</span>
                            <span class="n">segment_slope</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">slope_deviations</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">])</span>
                            <span class="n">new_point_y_val</span> <span class="o">=</span> <span class="n">new_dep_var_points</span><span class="p">[</span><span class="n">set_index</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta_x</span> <span class="o">*</span> <span class="n">segment_slope</span><span class="p">)</span>
                            <span class="n">new_dep_var_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_point_y_val</span><span class="p">)</span>
                        <span class="c1"># Now that we have all of our points, we apply a smoothing filter to our points so that</span>
                        <span class="c1"># our curve will not have as many sharp edges.</span>
                        <span class="n">smoothed_dep_var_points</span> <span class="o">=</span> <span class="n">lowess</span><span class="p">(</span><span class="n">new_dep_var_points</span><span class="p">,</span>
                                                         <span class="n">new_set_values</span><span class="p">[</span><span class="n">independent_var</span><span class="p">],</span>
                                                         <span class="n">is_sorted</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                                         <span class="n">frac</span><span class="o">=</span><span class="n">smoothing_fracs</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">],</span>
                                                         <span class="n">it</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_vars</span><span class="p">[</span><span class="n">dep_var_index</span><span class="p">]]</span> <span class="o">=</span> <span class="n">smoothed_dep_var_points</span>
                    <span class="n">new_data_dict</span><span class="p">[</span><span class="s2">&quot;Fake Dataset &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fake_set_num</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_set_values</span>
                <span class="k">return</span> <span class="n">new_data_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the length of location is more than one, we simply use recursion to narrow down the location:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                                    <span class="n">starting_noises</span><span class="p">,</span>
                                                                    <span class="n">slope_deviations</span><span class="p">,</span>
                                                                    <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                <span class="n">independent_var</span><span class="p">,</span>
                                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="n">location</span><span class="p">],</span>
                                                                <span class="n">starting_noises</span><span class="p">,</span>
                                                                <span class="n">slope_deviations</span><span class="p">,</span>
                                                                <span class="n">smoothing_fracs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location must be an iterable or a string!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">independent_var</span><span class="p">,</span>
                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                <span class="n">location</span><span class="p">,</span>
                                                <span class="n">randomness_amplitudes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method used by the make_fake_data_system_noise method to generate fake data. This method is seperate from</span>
<span class="sd">        that method because this method requires the use of recursion.</span>

<span class="sd">        **dictionary:** The dictionary that will be used as a reference for the fake data generation.</span>

<span class="sd">        **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">        This will not have random noise added to it.</span>

<span class="sd">        **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">        These will have random noise added to their values to generate new datasets.</span>

<span class="sd">        **num_datasets:** The amount of datasets to create.</span>

<span class="sd">        **location:** The location to generate fake data at.</span>

<span class="sd">        **randomness_amplitudes:** An iterable containing the random noise amplitudes for the random noise to be</span>
<span class="sd">        added to the values for each dependent variable.</span>

<span class="sd">        **returns:** A nested dictionary containing the newly generated data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="c1"># If it&#39;s length is one, that means that means that all of the values in the current dictionary</span>
            <span class="c1"># are SUPPOSED to be dictionaries representing singular datasets.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># the current_location variable is just there so I don&#39;t have to keep writing location[0] a ton.</span>
                <span class="n">current_location</span> <span class="o">=</span> <span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># new_data_dict will contain all of the new, fake datasets.</span>
                <span class="n">new_data_dict</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_datasets</span><span class="p">):</span>
                    <span class="c1"># We need a deep copy of one of the datasets so that</span>
                    <span class="c1"># when we add random noise it won&#39;t affect the original dataset:</span>
                    <span class="n">new_set_values</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span>
                                                   <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">current_location</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
                    <span class="c1"># Now we add random noise to every single dependent variable:</span>
                    <span class="k">for</span> <span class="n">dependent_var</span><span class="p">,</span> <span class="n">amp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dependent_vars</span><span class="p">,</span> <span class="n">randomness_amplitudes</span><span class="p">):</span>
                        <span class="n">num_values_in_dataset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_var</span><span class="p">])</span>
                        <span class="n">new_set_values</span><span class="p">[</span><span class="n">dependent_var</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">amp</span><span class="p">,</span> <span class="n">num_values_in_dataset</span><span class="p">)</span>
                    <span class="c1"># We now have a fake dataset, so we add it to new_data_dict, which contains all of our fake datasets</span>
                    <span class="n">new_data_dict</span><span class="p">[</span><span class="s2">&quot;Fake Dataset &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_set_values</span>
                <span class="c1"># ...and now we just return new_data_dict!</span>
                <span class="k">return</span> <span class="n">new_data_dict</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the length of location is more than one, we simply use recursion to narrow down the location:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">location</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                                    <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># If location is a string, the same method is called, but location is now a single element list,</span>
        <span class="c1"># so that The above code can do it&#39;s magic.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span>
                                                                <span class="n">independent_var</span><span class="p">,</span>
                                                                <span class="n">dependent_vars</span><span class="p">,</span>
                                                                <span class="n">num_datasets</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="n">location</span><span class="p">],</span>
                                                                <span class="n">randomness_amplitudes</span><span class="p">)</span>
        <span class="c1"># If location is not an iterable or a string, a ValueError is raised.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Location must be an iterable or a string!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts a nested dictionary with dataframes at the end of the nesting to a nested dictionary with</span>
<span class="sd">        dictionaries containing arrays representing columns at the end of the nesting.</span>

<span class="sd">        **dictionary:** The dictionary to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If dictionary is not a dict, an error is raised.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter &#39;dictionary&#39; is not a dict, it is a &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a dataframe,</span>
            <span class="c1"># it gets converted into a dictionary containing lists representing columns.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;list&#39;</span><span class="p">)</span>
                <span class="c1"># All of the lists are now converted to arrays.</span>
                <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">subkey</span><span class="p">])</span>
            <span class="c1"># If the value at the current key is a dict, it gets the method called on it.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method converts a nested dictionary with dictionaries containing arrays representing columns at the end of</span>
<span class="sd">        the nesting to a nested dictionary with dataframes at the end of the nesting.</span>

<span class="sd">        **dictionary: The dictionary to modify.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If dictionary is not a dict, an error is raised.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parameter &#39;dictionary&#39; is not a dict, it is a &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">dictionary</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># If the value at the current key is a dictionary containing arrays representing columns,</span>
            <span class="c1"># It gets converted to a dataframe.</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># If the value at the current key is a dict, it gets the method called on it.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                <span class="n">dictionary</span><span class="p">,</span>
                                                <span class="n">num_points</span><span class="p">,</span>
                                                <span class="n">independent_variable</span><span class="p">,</span>
                                                <span class="n">dependent_variables</span><span class="p">,</span>
                                                <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the method that actually interpolates the data in a nested dictionary, and is only called by</span>
<span class="sd">        the interpolate_data method. The reason why this method and the interpolate_data method are separate methods is</span>
<span class="sd">        because this method requires recursion.</span>

<span class="sd">        **dictionary:** A nested dictionary which will have its datasets interpolated.</span>

<span class="sd">        **num_points:** The amount of points the dependent variables will be interpolated to.</span>

<span class="sd">        **independent_variable:** The name of the independent variable of the dataset.</span>
<span class="sd">        All values of this variable must be increasing, and no duplicate values can exist.</span>

<span class="sd">        **dependent_variables:** An iterable containing the names of the dependent variables of the dataset.</span>

<span class="sd">        **interpolation_kind:** The kind of interpolation to be used. This will be fed into scipy&#39;s interp1d method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">dataset_key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">independent_variable</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Independent variable specified is not a key in the DictionarySystem!&quot;</span><span class="p">)</span>
                    <span class="c1"># All of this here is simple code to find these maxes of minimums and minimums of maxes:</span>
                    <span class="k">if</span> <span class="n">maximum_of_mins</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">maximum_of_mins</span><span class="p">:</span>
                        <span class="n">maximum_of_mins</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">minimum_of_maxes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">minimum_of_maxes</span><span class="p">:</span>
                        <span class="n">minimum_of_maxes</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                <span class="c1"># Now that we have the bounds for our interpolation, we need to make our interpolation functions:</span>
                <span class="k">for</span> <span class="n">dataset_key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="c1"># First we need to get the values for the independent and</span>
                    <span class="c1"># dependent variables in this specific dataset:</span>
                    <span class="n">independent_var_values</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">independent_variable</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">dependent_var_values</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">][</span><span class="n">variable_name</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">for</span> <span class="n">variable_name</span> <span class="ow">in</span> <span class="n">dependent_variables</span><span class="p">]</span>
                    <span class="c1"># This list will hold the interpolation functions soon:</span>
                    <span class="n">dependent_var_interpolation_functions</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">dependent_var_list</span> <span class="ow">in</span> <span class="n">dependent_var_values</span><span class="p">:</span>
                        <span class="c1"># Now, we simply use scipy&#39;s interp1d function to get our interpolation functions:</span>
                        <span class="n">var_function</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">independent_var_values</span><span class="p">,</span>
                                                            <span class="n">dependent_var_list</span><span class="p">,</span>
                                                            <span class="n">interpolation_kind</span><span class="p">)</span>
                        <span class="n">dependent_var_interpolation_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_function</span><span class="p">)</span>
                    <span class="c1"># The new independent variable values should be uniform, so we just use np.linspace:</span>
                    <span class="n">new_independent_var_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">maximum_of_mins</span><span class="p">,</span> <span class="n">minimum_of_maxes</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
                    <span class="c1"># This list will be used to store our dependent variable values</span>
                    <span class="c1"># once we use the interpolation functions we just made:</span>
                    <span class="n">new_dependent_var_values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="c1"># Now we go through our interpolation functions and</span>
                        <span class="c1"># get new values for all of our dependent variables:</span>
                        <span class="k">for</span> <span class="n">interp_function</span> <span class="ow">in</span> <span class="n">dependent_var_interpolation_functions</span><span class="p">:</span>
                            <span class="n">new_dependent_var_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interp_function</span><span class="p">(</span><span class="n">new_independent_var_values</span><span class="p">))</span>
                        <span class="c1"># We make a dictionary out of these new values using variable names as keys:</span>
                        <span class="n">interpolated_dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dependent_variables</span><span class="p">,</span> <span class="n">new_dependent_var_values</span><span class="p">))</span>
                        <span class="n">interpolated_dictionary</span><span class="p">[</span><span class="n">independent_variable</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_independent_var_values</span>
                        <span class="c1"># Finally, we replace our old DictionarySystem for this dataset with</span>
                        <span class="c1"># our newly interpolated one. By the way, we are inputting a dictionary, but the __setitem__</span>
                        <span class="c1"># method will convert it into an DictionarySystem, so we do not have to worry about that.</span>
                        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpolated_dictionary</span>
                    <span class="c1"># Sometimes interpolation fails because some dataset&#39;s bounds are outside of the</span>
                    <span class="c1"># interpolation range we just got, so this is here to just remove all the datasets that do that.</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">dataset_key</span><span class="p">]</span>
                        <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                                             <span class="n">num_points</span><span class="p">,</span>
                                                             <span class="n">independent_variable</span><span class="p">,</span>
                                                             <span class="n">dependent_variables</span><span class="p">,</span>
                                                             <span class="n">interpolation_kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Something went wrong, change this error message later&quot;</span><span class="p">)</span>

    <span class="c1"># Other Helper Methods:</span>
    <span class="k">def</span> <span class="nf">__get_nested_dictionaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This gets all of the dictionaries in the nested DictionarySystems</span>
<span class="sd">        and returns them as a nested dictionary structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This will soon contain all of the nested dictionaries in the DictionarySystem.</span>
        <span class="n">nested_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># This basically goes through the DictionarySystem, calling the same method on sub-DictionarySystems and</span>
        <span class="c1"># appending their results to the dictionary, as well as adding any non-DictionarySystem values to the dictionary</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
                <span class="n">nested_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nested_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Finally, our nested dictionary is just returned. Due to recursion, a full nested dictionary structure will</span>
        <span class="c1"># Eventually be outputted.</span>
        <span class="k">return</span> <span class="n">nested_dict</span>

    <span class="k">def</span> <span class="nf">__check_dictionary_validity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a dictionary has a valid format and valid variable types to become a DictionarySystem.</span>

<span class="sd">        **dictionary:** The dictionary to check.</span>

<span class="sd">        **returns:** True or False depending on whether a dictionary has a valid format and valid variable types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the dictionary variable inputted is not a dictionary, returns False.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># If any value in the dictionary is not a DictionarySystem, dictionary, or</span>
                <span class="c1"># pandas DataFrame, returns False.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="n">DictionarySystem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="c1"># If the __check_dictionary_validity method fails on any sub dictionaries, returns False.</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_dictionary_validity</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># If it never returned False, returns True.</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__convert_dicts_to_systems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts all sub-dictionaries in the DictionarySystem&#39;s main dictionary into DictionarySystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Literally all this does is if any value in the DictionarySystem is a dictionary, it gets turned into a</span>
        <span class="c1"># DictionarySystem.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__better_flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iterable_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Some flattening method I found on stackoverflow, which I a few methods</span>
<span class="sd">        to make the flattening of my columns arguments work.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable_object</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">newvalue</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">newvalue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">value</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#Machine_Learning.DictionarySystem">DictionarySystem</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, basedict)</p>
    </div>
    

    
  
    <div class="desc"><p>To initialize a DictionarySystem,
a nested dictionary must be inputted with the same format that a DictionarySystem uses.</p>
<p>An easy way to create a DictionarySystem is to use any of the following 4 functions:</p>
<ul>
<li>split_table_by_column</li>
<li>split_table_by_columns</li>
<li>split_csv_by_column</li>
<li>split_csv_by_columns</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.__init__', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basedict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To initialize a DictionarySystem,</span>
<span class="sd">    a nested dictionary must be inputted with the same format that a DictionarySystem uses.</span>
<span class="sd">    An easy way to create a DictionarySystem is to use any of the following 4 functions:</span>
<span class="sd">    * split_table_by_column</span>
<span class="sd">    * split_table_by_columns</span>
<span class="sd">    * split_csv_by_column</span>
<span class="sd">    * split_csv_by_columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Raises an error if basedict is not a dictionary.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;basedict must be a dictionary!&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">basedict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># Checks the validity of basedict. If basedict does not have the correct format,</span>
        <span class="c1"># or has value types that are not DictionarySystems, dictionaries,</span>
        <span class="c1"># or pandas Dataframes, raises a ValueError.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__check_dictionary_validity</span><span class="p">(</span><span class="n">basedict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">basedict</span>
            <span class="c1"># Converts all sub-dictionaries into DictionarySystems to</span>
            <span class="c1"># allow all of the recursive methods to work.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Basedict is not in a valid format, or has invalid value types!&quot;</span><span class="p">)</span>
    <span class="c1"># This is just in case something goes dreadfully wrong, but hopefully it will never be called.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Alright, I don&#39;t know what you even did, but something is wrong with basedict.&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.get">
    <p>def <span class="ident">get</span>(</p><p>self, key, default=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns a value for a given key inside the DictionarySystem's dictionary.</p>
<p><strong>key:</strong> the key to be searched in the dictionary.</p>
<p><strong>default:</strong> The value to be returned in case the key specified does not exist.</p>
<p><strong>returns:</strong> the value for the given key in side the FDictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.get', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.get" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a value for a given key inside the DictionarySystem&#39;s dictionary.</span>
<span class="sd">    **key:** the key to be searched in the dictionary.</span>
<span class="sd">    **default:** The value to be returned in case the key specified does not exist.</span>
<span class="sd">    **returns:** the value for the given key in side the FDictionarySystem&#39;s dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.get_dataset_variable_values">
    <p>def <span class="ident">get_dataset_variable_values</span>(</p><p>self, dataset_variable, location=None)</p>
    </div>
    

    
  
    <div class="desc"><p>This gets all of the values for a single variable, and returns them in an array containing lists containing the
datapoints for the variable for a single dataset. This is used by a lot of methods, and in general is a format
that is somewhat easy to work with.</p>
<p><strong>dataset_variable:</strong> The name of the variable to get all of the values for.</p>
<p><strong>location:</strong> The location to get the variable values from. If it is none, all of the values for the variable
will be gotten.</p>
<p><strong>returns:</strong> All of the values of a single variable in an array, with the values being seperated into lists
containing the values for a single dataset.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.get_dataset_variable_values', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.get_dataset_variable_values" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_dataset_variable_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset_variable</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This gets all of the values for a single variable, and returns them in an array containing lists containing the</span>
<span class="sd">    datapoints for the variable for a single dataset. This is used by a lot of methods, and in general is a format</span>
<span class="sd">    that is somewhat easy to work with.</span>
<span class="sd">    **dataset_variable:** The name of the variable to get all of the values for.</span>
<span class="sd">    **location:** The location to get the variable values from. If it is none, all of the values for the variable</span>
<span class="sd">    will be gotten.</span>
<span class="sd">    **returns:** All of the values of a single variable in an array, with the values being seperated into lists</span>
<span class="sd">    containing the values for a single dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
    <span class="n">dataset_variable_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_get_dataset_variable_values</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                                   <span class="n">dataset_variable</span><span class="p">,</span>
                                                                                   <span class="n">location</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dataset_variable_values</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.interpolate_data">
    <p>def <span class="ident">interpolate_data</span>(</p><p>self, num_points, independent_variable, dependent_variables, interpolation_kind=&#39;cubic&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Interpolates independent and dependent variables in datasets within the DictionarySystem to have the amount
of points specified. Unfortunately, columns that are not the independent or dependent variables will be removed,
since they are not being interpolated and the dataframe has to stay rectangular.</p>
<p>The independent variable must not have repeat values, and must be increasing. If these two requirements are not
fulfilled, the method will fail.</p>
<p><strong>num_points:</strong> The amount of points the dependent variables will be interpolated to.</p>
<p><strong>independent_variable:</strong> The name of the independent variable of the dataset.
All values of this variable must be increasing, and no duplicate values can exist.</p>
<p><strong>dependent_variables:</strong> An iterable containing the names of the dependent variables of the dataset.</p>
<p><strong>interpolation_kind:</strong> The kind of interpolation to be used. This will be fed into scipy's interp1d method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.interpolate_data', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.interpolate_data" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">interpolate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">num_points</span><span class="p">,</span>
                     <span class="n">independent_variable</span><span class="p">,</span>
                     <span class="n">dependent_variables</span><span class="p">,</span>
                     <span class="n">interpolation_kind</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates independent and dependent variables in datasets within the DictionarySystem to have the amount</span>
<span class="sd">    of points specified. Unfortunately, columns that are not the independent or dependent variables will be removed,</span>
<span class="sd">    since they are not being interpolated and the dataframe has to stay rectangular.</span>
<span class="sd">    The independent variable must not have repeat values, and must be increasing. If these two requirements are not</span>
<span class="sd">    fulfilled, the method will fail.</span>
<span class="sd">    **num_points:** The amount of points the dependent variables will be interpolated to.</span>
<span class="sd">    **independent_variable:** The name of the independent variable of the dataset.</span>
<span class="sd">    All values of this variable must be increasing, and no duplicate values can exist.</span>
<span class="sd">    **dependent_variables:** An iterable containing the names of the dependent variables of the dataset.</span>
<span class="sd">    **interpolation_kind:** The kind of interpolation to be used. This will be fed into scipy&#39;s interp1d method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
    <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
    <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
    <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
    <span class="c1"># containing arrays representing columns.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
    <span class="c1"># Now that our data is in a format that is easy to work with, we actually interpolate our data.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_dictionary_interpolation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                 <span class="n">num_points</span><span class="p">,</span>
                                                 <span class="n">independent_variable</span><span class="p">,</span>
                                                 <span class="n">dependent_variables</span><span class="p">,</span>
                                                 <span class="n">interpolation_kind</span><span class="o">=</span><span class="n">interpolation_kind</span><span class="p">)</span>
    <span class="c1"># Now that our data is interpolated, we convert all of the dictionaries containing</span>
    <span class="c1"># arrays representing columns back to dataframes.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
    <span class="c1"># We replace our object&#39;s dictionary with the newly interpolated one.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span> <span class="o">=</span> <span class="n">nested_dictionaries</span>
    <span class="c1"># Now we simply convert all sub-dictionaries to DictionarySystems</span>
    <span class="c1"># to get everything back into the correct format.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__convert_dicts_to_systems</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.items">
    <p>def <span class="ident">items</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This returns the key,value pairs of the DictionarySystem's dictionary in tuples.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.items', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.items" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This returns the key,value pairs of the DictionarySystem&#39;s dictionary in tuples.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.iteritems">
    <p>def <span class="ident">iteritems</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the iterator returned by the iteritems method of the DictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.iteritems', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.iteritems" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iteritems method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.iterkeys">
    <p>def <span class="ident">iterkeys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the iterator returned by the iterkeys method of the DictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.iterkeys', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.iterkeys" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the iterkeys method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.itervalues">
    <p>def <span class="ident">itervalues</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Returns the iterator returned by the itervalues method of the DictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.itervalues', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.itervalues" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the iterator returned by the itervalues method of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">itervalues</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.keep_only_certain_columns">
    <p>def <span class="ident">keep_only_certain_columns</span>(</p><p>self, *columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes all columns in every table except the ones specified.
This is generally used to remove irrelevant data from tables.</p>
<p><strong>columns:</strong> The names of the columns to keep in every table.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.keep_only_certain_columns', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.keep_only_certain_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">keep_only_certain_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes all columns in every table except the ones specified.</span>
<span class="sd">    This is generally used to remove irrelevant data from tables.</span>
<span class="sd">    **columns:** The names of the columns to keep in every table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If no columns are specified, the method raises a ValueError</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
    <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
    <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
    <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
    <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
    <span class="c1"># The method now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
    <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
    <span class="c1"># and the method would be okay with it.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># Now, most of the error checking is done, so the method starts</span>
    <span class="c1"># going through the keys in the DictionarySystem.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># If the value at the current key is a DictionarySystem,</span>
        <span class="c1"># the keep_only_certain_columns method is called on that.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">keep_only_certain_columns</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span>
        <span class="c1"># If the value a the current key is a DataFrame, the method sets the value at the current key to a new</span>
        <span class="c1"># DataFrame that only has the columns specified.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">columns_flattened</span><span class="p">]</span>
        <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
        <span class="c1"># the method will raise an error.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.keys">
    <p>def <span class="ident">keys</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This returns the keys of the DictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.keys', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.keys" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This returns the keys of the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.make_fake_data_system_noise">
    <p>def <span class="ident">make_fake_data_system_noise</span>(</p><p>self, independent_var, dependent_vars, num_datasets, location, randomness_amplitudes)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to
the dependent variables of real datasets.</p>
<p><strong>independent_var:</strong> The name of the independent variable of the datasets.
This will not have random noise added to it.</p>
<p><strong>dependent_vars:</strong> An Iterable containing the names of the dependent variables of the datasets.
These will have random noise added to their values to generate new datasets.</p>
<p><strong>num_datasets:</strong> The amount of datasets to create</p>
<p><strong>location:</strong> The location to generate fake data at.</p>
<p><strong>randomness_amplitudes</strong> An iterable containing the random noise amplitudes for the random noise to be
added to the values for each dependent variable.</p>
<p><strong>returns:</strong> A new DictionarySystem containing automatically generated datasets.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.make_fake_data_system_noise', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.make_fake_data_system_noise" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_fake_data_system_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">independent_var</span><span class="p">,</span>
                                <span class="n">dependent_vars</span><span class="p">,</span>
                                <span class="n">num_datasets</span><span class="p">,</span>
                                <span class="n">location</span><span class="p">,</span>
                                <span class="n">randomness_amplitudes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to</span>
<span class="sd">    the dependent variables of real datasets.</span>
<span class="sd">    **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">    This will not have random noise added to it.</span>
<span class="sd">    **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">    These will have random noise added to their values to generate new datasets.</span>
<span class="sd">    **num_datasets:** The amount of datasets to create</span>
<span class="sd">    **location:** The location to generate fake data at.</span>
<span class="sd">    **randomness_amplitudes** An iterable containing the random noise amplitudes for the random noise to be</span>
<span class="sd">    added to the values for each dependent variable.</span>
<span class="sd">    **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
    <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
    <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
    <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
    <span class="c1"># containing arrays representing columns.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
    <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
    <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
    <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_noise_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">,</span>
                                                                    <span class="n">randomness_amplitudes</span><span class="p">)</span>
    <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
    <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
    <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.make_fake_data_system_slope">
    <p>def <span class="ident">make_fake_data_system_slope</span>(</p><p>self, independent_var, dependent_vars, num_datasets, location, starting_noises, slope_deviations, smoothing_fracs)</p>
    </div>
    

    
  
    <div class="desc"><p>Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to the
first points of already existing datasets then adding random noise to the slopes between points of existing
datasets and creating new points based off of those. After all this is done, a smoothing filter is applied to
make the generated lines less jagged.</p>
<p><strong>independent_var:</strong> The name of the independent variable of the datasets.
This will not be modified during fake data creation.</p>
<p><strong>dependent_vars:</strong> An Iterable containing the names of the dependent variables of the datasets.
Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</p>
<p><strong>num_datasets:</strong> The amount of datasets to be generated.</p>
<p><strong>location:</strong> The location to get datasets to be used to generate new datasets.</p>
<p><strong>starting_noises:</strong> An Iterable containing the random noise amplitudes for the random noise to be added to
each dependent variable in existing datasets to generate new datasets.</p>
<p><strong>slope_deviations:</strong> An Iterable containing the random noise amplitudes for the random noise to be added to
the slopes of the lines for each dependent variable to generate new datasets.</p>
<p><strong>smoothing_fracs:</strong> An Iterable containing the smoothing fracs for the lowess filter to apply to the
generated lines for each dependent variable.</p>
<p><strong>returns:</strong> A new DictionarySystem containing automatically generated datasets.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.make_fake_data_system_slope', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.make_fake_data_system_slope" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">make_fake_data_system_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                <span class="n">independent_var</span><span class="p">,</span>
                                <span class="n">dependent_vars</span><span class="p">,</span>
                                <span class="n">num_datasets</span><span class="p">,</span>
                                <span class="n">location</span><span class="p">,</span>
                                <span class="n">starting_noises</span><span class="p">,</span>
                                <span class="n">slope_deviations</span><span class="p">,</span>
                                <span class="n">smoothing_fracs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a new DictionarySystem containing automatically generated datasets created by adding random noise to the</span>
<span class="sd">    first points of already existing datasets then adding random noise to the slopes between points of existing</span>
<span class="sd">    datasets and creating new points based off of those. After all this is done, a smoothing filter is applied to</span>
<span class="sd">    make the generated lines less jagged.</span>
<span class="sd">    **independent_var:** The name of the independent variable of the datasets.</span>
<span class="sd">    This will not be modified during fake data creation.</span>
<span class="sd">    **dependent_vars:** An Iterable containing the names of the dependent variables of the datasets.</span>
<span class="sd">    Values of these variables in existing datasets will have modifications applied to them to generate new datasets.</span>
<span class="sd">    **num_datasets:** The amount of datasets to be generated.</span>
<span class="sd">    **location:** The location to get datasets to be used to generate new datasets.</span>
<span class="sd">    **starting_noises:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">    each dependent variable in existing datasets to generate new datasets.</span>
<span class="sd">    **slope_deviations:** An Iterable containing the random noise amplitudes for the random noise to be added to</span>
<span class="sd">    the slopes of the lines for each dependent variable to generate new datasets.</span>
<span class="sd">    **smoothing_fracs:** An Iterable containing the smoothing fracs for the lowess filter to apply to the</span>
<span class="sd">    generated lines for each dependent variable.</span>
<span class="sd">    **returns:** A new DictionarySystem containing automatically generated datasets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Gets all of the nested dictionaries within the DictionarySystem.</span>
    <span class="c1"># This basically just gets the entire nested dictionary structure without any DictionarySystems in it.</span>
    <span class="n">nested_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_nested_dictionaries</span><span class="p">()</span>
    <span class="c1"># This converts all dataframes at the end of the nested dictionary structure to dictionaries</span>
    <span class="c1"># containing arrays representing columns.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_dataframes_to_arrays</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">)</span>
    <span class="c1"># Now that our data is in a format that is somewhat easy to work with, we actually create the fake data.</span>
    <span class="c1"># I had to use a seperate method here since my method of creating fake data used recursion.</span>
    <span class="n">new_dictionaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nested_array_fake_slope_data_creation</span><span class="p">(</span><span class="n">nested_dictionaries</span><span class="p">,</span>
                                                                    <span class="n">independent_var</span><span class="p">,</span>
                                                                    <span class="n">dependent_vars</span><span class="p">,</span>
                                                                    <span class="n">num_datasets</span><span class="p">,</span>
                                                                    <span class="n">location</span><span class="p">,</span>
                                                                    <span class="n">starting_noises</span><span class="p">,</span>
                                                                    <span class="n">slope_deviations</span><span class="p">,</span>
                                                                    <span class="n">smoothing_fracs</span><span class="p">)</span>
    <span class="c1"># Now that we have our fake data, we convert all the dictonaries of arrays representing columns to dataframes.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__nested_dictionary_arrays_to_dataframes</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
    <span class="c1"># Finally we convert this dictionary into a DictionarySystem and return it.</span>
    <span class="k">return</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dictionaries</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.pop">
    <p>def <span class="ident">pop</span>(</p><p>self, key, default=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Pops the value at the given key from the DictionarySystem's dictionary and returns it.</p>
<p><strong>key:</strong> The key to pop the value from</p>
<p><strong>default:</strong> If the given key does not exist within the DictionarySystem's dictionary,
this value will be returned.</p>
<p><strong>returns:</strong> The value that was just popped from the given key.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.pop', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.pop" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pops the value at the given key from the DictionarySystem&#39;s dictionary and returns it.</span>
<span class="sd">    **key:** The key to pop the value from</span>
<span class="sd">    **default:** If the given key does not exist within the DictionarySystem&#39;s dictionary,</span>
<span class="sd">    this value will be returned.</span>
<span class="sd">    **returns:** The value that was just popped from the given key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.remove_column_duplicates">
    <p>def <span class="ident">remove_column_duplicates</span>(</p><p>self, column)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes all rows that have a duplicate value in a specific column
except one in every table in the DictionarySystem,
so that no duplicates in the said column will remain in the DictionarySystem.</p>
<p>The way this removes columns is by going through each DataFrame in the DictionarySystem, and,
for each DataFrame, a new DataFrame is created containing the first rows containing unique values in the initial
DataFrame. The old DataFrame is then overwritten.</p>
<p><strong>column:</strong> The column used to remove duplicate values.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.remove_column_duplicates', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.remove_column_duplicates" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_column_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes all rows that have a duplicate value in a specific column</span>
<span class="sd">    except one in every table in the DictionarySystem,</span>
<span class="sd">    so that no duplicates in the said column will remain in the DictionarySystem.</span>
<span class="sd">    The way this removes columns is by going through each DataFrame in the DictionarySystem, and,</span>
<span class="sd">    for each DataFrame, a new DataFrame is created containing the first rows containing unique values in the initial</span>
<span class="sd">    DataFrame. The old DataFrame is then overwritten.</span>
<span class="sd">    **column:** The column used to remove duplicate values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_column_duplicates on that.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_column_duplicates</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="c1"># otherwise, if the value at the current key is a pandas DataFrame, it starts removing column duplicates.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># It sets the variable new_dataframe to none since I didn&#39;t want the variable to be local to</span>
            <span class="c1"># the for loop and I couldn&#39;t figure out any other way to do that.</span>
            <span class="n">new_dataframe</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="c1"># The method goes through all the unique values of the column specified.</span>
            <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                <span class="c1"># Inside the for loop, the method creates a new DataFrame containing all the rows where the value</span>
                <span class="c1"># in the specified column is the same as the for loop&#39;s unique value. It then selects the first</span>
                <span class="c1"># row in that DataFrame and adds it to the new_dataframe variable. The result at the end of the</span>
                <span class="c1"># for loop is a new dataframe where duplicate values in the specified column have been removed.</span>
                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">new_dataframe</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">new_dataframe</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">]]])</span>
            <span class="c1"># Finally the method just resets the index of this new DataFrame and sets the value at the current key</span>
            <span class="c1"># to be the new DataFrame with duplicate values removed, replacing the old DataFrame.</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dataframe</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
        <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.remove_short_tables">
    <p>def <span class="ident">remove_short_tables</span>(</p><p>self, row_count)</p>
    </div>
    

    
  
    <div class="desc"><p>Removes all tables in the DictionarySystem that are below a certain row count.</p>
<p><strong>row_count:</strong> The row count required for a table to stay in the DictionarySystem.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.remove_short_tables', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.remove_short_tables" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">remove_short_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_count</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes all tables in the DictionarySystem that are below a certain row count.</span>
<span class="sd">    **row_count:** The row count required for a table to stay in the DictionarySystem.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># If the value at the current key is a DictionarySystem, it calls remove_short_tables on that.</span>
        <span class="c1"># If the DictionarySystem has no tables left in it after that, the method deletes the current key.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove_short_tables</span><span class="p">(</span><span class="n">row_count</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># If the value at the current key is a pandas DataFrame and it&#39;s row count is</span>
        <span class="c1"># less than the specified minimum row count, the method deletes the current key.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row_count</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># If the value at the current key is not a DictionarySystem or pandas DataFrame,</span>
        <span class="c1"># the method raises a ValueError.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem has a value that isn&#39;t a DictionarySystem or Pandas DataFrame!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.split_by_column">
    <p>def <span class="ident">split_by_column</span>(</p><p>self, column)</p>
    </div>
    

    
  
    <div class="desc"><p>Splits the dictionary system's tables by a single column,
making the location where the table was a dictionary containing unique column values in the column as keys,
with each key containing a table.</p>
<p><strong>column:</strong> The column to split the dictionary systems by.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.split_by_column', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.split_by_column" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_by_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the dictionary system&#39;s tables by a single column,</span>
<span class="sd">    making the location where the table was a dictionary containing unique column values in the column as keys,</span>
<span class="sd">    with each key containing a table.</span>
<span class="sd">    **column:** The column to split the dictionary systems by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># If the value at that key is a DictionarySystem it calls split_by_column on that.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">DictionarySystem</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="c1"># If the value at that key is a pandas DataFrame it tries to split it:</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="c1"># If the column specified is not in the DataFrame, the method raises a KeyError.</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Column Specified is not in a table!&quot;</span><span class="p">)</span>
            <span class="n">unique_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="n">new_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># The method goes through all of the unique values in the column in the table,</span>
            <span class="c1"># creates new DataFrames containing only the unique value specified, and adds them to a dictionary.</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unique_vals</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">]</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">new_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span>
            <span class="c1"># The dictionary is then set to be the new value of the key.</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">DictionarySystem</span><span class="p">(</span><span class="n">new_dict</span><span class="p">)</span>
        <span class="c1"># The method will raise an error if the DictionarySystem contains</span>
        <span class="c1"># values other than DictionarySystems and pandas DataFrames.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DictionarySystem contains values other than DictionarySystems and tables!&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.split_by_columns">
    <p>def <span class="ident">split_by_columns</span>(</p><p>self, *columns)</p>
    </div>
    

    
  
    <div class="desc"><p>Does the same thing as the split_by_column method, except splits by multiple columns in order instead of one.</p>
<p><strong>columns:</strong> The names of each column to split the tables by.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.split_by_columns', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.split_by_columns" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">split_by_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">columns</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does the same thing as the split_by_column method, except splits by multiple columns in order instead of one.</span>
<span class="sd">    **columns:** The names of each column to split the tables by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If no columns are specified, the method raises a ValueError</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># Since we now know that columns has some values in it, the method flattens the list of columns.</span>
    <span class="c1"># I added this so users can input complex nested list systems and stuff as arguments for this method.</span>
    <span class="n">columns_flattened</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__better_flatten</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
    <span class="c1"># Now, the method goes through the columns_flattened list and checks if each one of them is a string.</span>
    <span class="c1"># If one of them is not a string, it clearly isn&#39;t a column name, so the methos raises a ValueError.</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Value other than Iterable or String specified as a column!&quot;</span><span class="p">)</span>
    <span class="c1"># Jeez, I just realized that like 90% of this entire method is error checking.</span>
    <span class="c1"># Anyway, this now checks if the length of columns_flattened is 0, and if it is, throws an error.</span>
    <span class="c1"># I added this because otherwise people could put in a lot of lists and no string column names</span>
    <span class="c1"># and the method would be okay with it.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns_flattened</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one column value must be specified!&quot;</span><span class="p">)</span>
    <span class="c1"># finally, after all that error checking, the method goes through the columns_flattened list in order, and</span>
    <span class="c1"># calls split_by_column with each column.</span>
    <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns_flattened</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_by_column</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="Machine_Learning.DictionarySystem.values">
    <p>def <span class="ident">values</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>This returns a list of all the values in the DictionarySystem's dictionary.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-Machine_Learning.DictionarySystem.values', this);">Show source &equiv;</a></p>
  <div id="source-Machine_Learning.DictionarySystem.values" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This returns a list of all the values in the DictionarySystem&#39;s dictionary.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>